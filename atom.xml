<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>凌风仙鸡的 Blog&amp;Diary</title>
  
  <subtitle>春去秋来，影射飞快</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2018-09-15T07:44:44.123Z</updated>
  <id>/</id>
  
  <author>
    <name>凌风仙鸡</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>非旋转 Treap 模板</title>
    <link href="/posts/fhqTreap-template/"/>
    <id>/posts/fhqTreap-template/</id>
    <published>2018-09-15T07:44:33.000Z</published>
    <updated>2018-09-15T07:44:44.123Z</updated>
    
    <content type="html"><![CDATA[<p>题目传送门: <a href="https://www.luogu.org/problemnew/show/P3369" target="_blank" rel="noopener">洛谷 P3369</a>、<a href="https://loj.ac/problem/104" target="_blank" rel="noopener">LibreOJ #104</a>、<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3224" target="_blank" rel="noopener">BZOJ 3224</a></p><p>我们需要实现一种数据结构，实现以下操作。</p><ol><li>插入 $ x $ 数；</li><li>删除 $ x $ 数（若有多个相同的数，因只删除一个）；</li><li>查询 $ x $ 数的排名（若有多个相同的数，因输出最小的排名）；</li><li>查询排名为 $ x $ 的数；</li><li>求 $ x $ 的前趋（前趋定义为小于 $ x $，且最大的数）；</li><li>求 $ x $ 的后继（后继定义为大于 $ x $，且最小的数）。</li></ol><p>很明显，可以通过 Splay 来做，但是我不会，因此我们可以使用非旋转 Treap 来做。</p><p>AC 代码:</p><pre><code class="lang-cpp">#include &lt;cstdio&gt;const int MAXN = 200000 + 10;namespace fhqTreap {    const int INF = 0x7fffffff;    inline int rand() {        static unsigned long long seed = 19260817;        return seed = (seed * 47821 + 0x1317D1E) % 0x1317CB3;    }    int root, count;    struct Node {        int l, r, k, rd, size;        Node() {}        Node(int k) : l(0), r(0), k(k), rd(rand()), size(1) {}    } node[MAXN];    void update(int const n) {        node[n].size = (node[n].l ? node[node[n].l].size : 0) + (node[n].r ? node[node[n].r].size : 0) + 1;    }    void split(int const n, int const k, int &amp;x, int &amp;y) {        if (!n) x = y = 0;        else if (k &lt;= node[n].k) {            split(node[n].l, k, x, y);            node[n].l = y;            update(y = n);        }        else {            split(node[n].r, k, x, y);            node[n].r = x;            update(x = n);        }    }    int merge(int const x, int const y) {        if (!x || !y) return x + y;        if (node[x].rd &lt; node[y].rd) {            node[x].r = merge(node[x].r, y);            return update(x), x;        }        else {            node[y].l = merge(x, node[y].l); // X &lt; NODE[Y].L!!!!!!!!!            return update(y), y;        }    }    inline void insert(int const &amp;k) {        int x, y;        split(root, k, x, y);        node[++count] = Node(k);        root = merge(merge(x, count), y);    }    inline void remove(int const &amp;k) {        int x, y, z;        split(root, k, x, z), split(z, k + 1, z, y);        z = merge(node[z].l, node[z].r);        root = merge(merge(x, z), y);    }    inline int rank(int const &amp;k) {        int x, y, ans;        split(root, k, x, y);        if (!x) return (root = merge(x, y)), 1;        ans = node[x].size + 1;        return (root = merge(x, y)), ans;    }    inline int search(int const rk, int n = root) {        int rank = (node[n].l ? node[node[n].l].size : 0) + 1;        if (rank == rk) return node[n].k;        if (rk &lt; rank) {            return search(rk, node[n].l);        }        else {            return search(rk - rank, node[n].r);        }    }    inline int lower(int const k) {        int x, y, t;        split(root, k, x, y), t = x;        if (!x) return -INF;        while (node[t].r) t = node[t].r;        return (root = merge(x, y)), node[t].k;    }    inline int upper(int const k) {        int x, y, t;        split(root, k + 1, x, y), t = y;        if (!y) return INF;        while(node[t].l) t = node[t].l;        return (root = merge(x, y)), node[t].k;    }}int n, opt, x;int main(int argc, char const *argv[]) {    scanf(&quot;%d&quot;, &amp;n);    while (n--) {        scanf(&quot;%d %d&quot;, &amp;opt, &amp;x);        switch(opt) {            case 1:                fhqTreap::insert(x);                break;            case 2:                fhqTreap::remove(x);                break;            case 3:                printf(&quot;%d\n&quot;, fhqTreap::rank(x));                break;            case 4:                printf(&quot;%d\n&quot;, fhqTreap::search(x));                break;            case 5:                printf(&quot;%d\n&quot;, fhqTreap::lower(x));                break;            case 6:                printf(&quot;%d\n&quot;, fhqTreap::upper(x));                break;        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目传送门: &lt;a href=&quot;https://www.luogu.org/problemnew/show/P3369&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;洛谷 P3369&lt;/a&gt;、&lt;a href=&quot;https://loj.ac/problem/104&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LibreOJ #104&lt;/a&gt;、&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=3224&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ 3224&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们需要实现一种数据结构，实现以下操作。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;插入 $ x $ 数；&lt;/li&gt;
&lt;li&gt;删除 $ x $ 数（若有多个相同的数，因只删除一个）；&lt;/li&gt;
&lt;li&gt;查询 $ x $ 数的排名（若有多个相同的数，因输出最小的排名）；&lt;/li&gt;
&lt;li&gt;查询排名为 $ x $ 的数；&lt;/li&gt;
&lt;li&gt;求 $ x $ 的前趋（前趋定义为小于 $ x $，且最大的数）；&lt;/li&gt;
&lt;li&gt;求 $ x $ 的后继（后继定义为大于 $ x $，且最小的数）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;很明显，可以通过 Splay 来做，但是我不会，因此我们可以使用非旋转 Treap 来做。&lt;/p&gt;
&lt;p&gt;AC 代码:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;#include &amp;lt;cstdio&amp;gt;
const int MAXN = 200000 + 10;
namespace fhqTreap {
    const int INF = 0x7fffffff;
    inline int rand() {
        static unsigned long long seed = 19260817;
        return seed = (seed * 47821 + 0x1317D1E) % 0x1317CB3;
    }
    int root, count;
    struct Node {
        int l, r, k, rd, size;
        Node() {}
        Node(int k) : l(0), r(0), k(k), rd(rand()), size(1) {}
    } node[MAXN];
    void update(int const n) {
        node[n].size = (node[n].l ? node[node[n].l].size : 0) + (node[n].r ? node[node[n].r].size : 0) + 1;
    }
    void split(int const n, int const k, int &amp;amp;x, int &amp;amp;y) {
        if (!n) x = y = 0;
        else if (k &amp;lt;= node[n].k) {
            split(node[n].l, k, x, y);
            node[n].l = y;
            update(y = n);
        }
        else {
            split(node[n].r, k, x, y);
            node[n].r = x;
            update(x = n);
        }
    }
    int merge(int const x, int const y) {
        if (!x || !y) return x + y;
        if (node[x].rd &amp;lt; node[y].rd) {
            node[x].r = merge(node[x].r, y);
            return update(x), x;
        }
        else {
            node[y].l = merge(x, node[y].l); // X &amp;lt; NODE[Y].L!!!!!!!!!
            return update(y), y;
        }
    }
    inline void insert(int const &amp;amp;k) {
        int x, y;
        split(root, k, x, y);
        node[++count] = Node(k);
        root = merge(merge(x, count), y);

    }
    inline void remove(int const &amp;amp;k) {
        int x, y, z;
        split(root, k, x, z), split(z, k + 1, z, y);
        z = merge(node[z].l, node[z].r);
        root = merge(merge(x, z), y);
    }
    inline int rank(int const &amp;amp;k) {
        int x, y, ans;
        split(root, k, x, y);
        if (!x) return (root = merge(x, y)), 1;
        ans = node[x].size + 1;
        return (root = merge(x, y)), ans;
    }
    inline int search(int const rk, int n = root) {
        int rank = (node[n].l ? node[node[n].l].size : 0) + 1;
        if (rank == rk) return node[n].k;
        if (rk &amp;lt; rank) {
            return search(rk, node[n].l);
        }
        else {
            return search(rk - rank, node[n].r);
        }
    }
    inline int lower(int const k) {
        int x, y, t;
        split(root, k, x, y), t = x;
        if (!x) return -INF;
        while (node[t].r) t = node[t].r;
        return (root = merge(x, y)), node[t].k;
    }

    inline int upper(int const k) {
        int x, y, t;
        split(root, k + 1, x, y), t = y;
        if (!y) return INF;
        while(node[t].l) t = node[t].l;
        return (root = merge(x, y)), node[t].k;
    }
}
int n, opt, x;
int main(int argc, char const *argv[]) {
    scanf(&amp;quot;%d&amp;quot;, &amp;amp;n);

    while (n--) {
        scanf(&amp;quot;%d %d&amp;quot;, &amp;amp;opt, &amp;amp;x);
        switch(opt) {
            case 1:
                fhqTreap::insert(x);
                break;
            case 2:
                fhqTreap::remove(x);
                break;
            case 3:
                printf(&amp;quot;%d\n&amp;quot;, fhqTreap::rank(x));
                break;
            case 4:
                printf(&amp;quot;%d\n&amp;quot;, fhqTreap::search(x));
                break;
            case 5:
                printf(&amp;quot;%d\n&amp;quot;, fhqTreap::lower(x));
                break;
            case 6:
                printf(&amp;quot;%d\n&amp;quot;, fhqTreap::upper(x));
                break;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

    
    </summary>
    
    
      <category term="OI" scheme="/tags/OI/"/>
    
      <category term="算法模板" scheme="/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="数据结构" scheme="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="平衡树" scheme="/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>SNIProxy 实现服务器反向代理多个带加密网站</title>
    <link href="/posts/https-requests-forwarding-using-sniproxy/"/>
    <id>/posts/https-requests-forwarding-using-sniproxy/</id>
    <published>2018-08-18T08:04:27.000Z</published>
    <updated>2018-08-18T08:05:39.035Z</updated>
    
    <content type="html"><![CDATA[<p>之前通过 FRP 来实现了单个网站不泄露证书的 HTTPS 反向代理，但是缺点是一台服务器只能代理一个网站，即一个前端只能对应一个后端。这多少有些不够方便，也不方便与他人合租一台服务器。</p><p>SNIProxy 则是一个不错的解决方案。它通过浏览器访问时提供的 SNI 头来判断访问域名，然后可以根据域名来选择转发请求到何处。由于这个过程不涉及加密和解密，因此除了匹配正则表达式几乎没有性能损失，同时也不需要在前端服务器上部署 HTTPS 证书，也无需担心数据泄露的问题。<br>本教程适用的 Linux 发行版为 CentOS 7.4。</p><h2 id="安装-SNIProxy"><a href="#安装-SNIProxy" class="headerlink" title="安装 SNIProxy"></a>安装 SNIProxy</h2><p>SNIProxy 这个软件并不在大多数 Linux 操作系统默认的软件源中。因此需要手动编译以及安装。<br>编译安装教程可以参考软件官方 README.md。项目的地址是: <a href="https://github.com/dlundquist/sniproxy" target="_blank" rel="noopener">SNIProxy on GitHub</a>。<br>我这里也提供一个打包好的 RPM 包，可直接通过 <code>yum</code> 安装在 CentOS 7 上。下载地址为 <a href="https://cloud.imvictor.tech/s/b8WqDWsJcrbgfLQ" target="_blank" rel="noopener">Cloud Storage</a>。  </p><h2 id="配置-SNIProxy"><a href="#配置-SNIProxy" class="headerlink" title="配置 SNIProxy"></a>配置 SNIProxy</h2><p>安装好包之后，SNIProxy 应该已经在 <code>/usr/sbin/sniproxy</code> 了。<br>在大多数情况下，我们希望它作为一个服务启动，这样方便管理。但 SNIProxy 并没有把自己安装为服务，因此需要我们手动添加。<br>将以下内容放置到 <code>/etc/systemd/system/sniproxy.service</code>。</p><pre><code class="lang-ini">[Unit]Description=SNIProxy[Service]Type=simpleExecStart=/usr/sbin/sniproxy -fStandardOutput=nullRestart=on-failure[Install]WantedBy=multi-user.target</code></pre><p>这样就可以通过 <code>systemctl</code> 来控制 SNIProxy 了。<br>然后我们需要编辑 SNIProxy 的配置文件 <code>/etc/sniproxy.conf</code>，配置文件示例参见官方 README。 </p><p>下面有几点小提示:</p><ol><li>注意，<code>listener</code> 后面如果带有 <code>127.0.0.1</code>，则只有本机才能传入连接。因此，一般推荐把 <code>listener 127.0.0.1:443</code>，改为 <code>listener 443</code>。 </li><li><code>fallback</code> 参数的意思类似于 switch-case 语句的 <code>default</code> 选项。即所有给出的情况全部失配后，选择将请求转发到这个参数所配置的服务器上。</li><li>SNIProxy 也可以转发 HTTP 流量，只要把 <code>protocol</code> 后面的 <code>tls</code> 改成 <code>http</code> 即可。</li></ol><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>对于 FRP 端口映射前端服务器，建议开启防火墙，保证所有流量都能经过 SNIProxy。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前通过 FRP 来实现了单个网站不泄露证书的 HTTPS 反向代理，但是缺点是一台服务器只能代理一个网站，即一个前端只能对应一个后端。这多少有些不够方便，也不方便与他人合租一台服务器。&lt;/p&gt;
&lt;p&gt;SNIProxy 则是一个不错的解决方案。它通过浏览器访问时提供的 SNI 头来判断访问域名，然后可以根据域名来选择转发请求到何处。由于这个过程不涉及加密和解密，因此除了匹配正则表达式几乎没有性能损失，同时也不需要在前端服务器上部署 HTTPS 证书，也无需担心数据泄露的问题。&lt;br&gt;本教程适用的 Linux 发行版为 CentOS 7.4。&lt;/p&gt;
&lt;h2 id=&quot;安装-SNIProxy&quot;&gt;&lt;a href=&quot;#安装-SNIProxy&quot; class=&quot;headerlink&quot; title=&quot;安装 SNIProxy&quot;&gt;&lt;/a&gt;安装 SNIProxy&lt;/h2&gt;&lt;p&gt;SNIProxy 这个软件并不在大多数 Linux 操作系统默认的软件源中。因此需要手动编译以及安装。&lt;br&gt;编译安装教程可以参考软件官方 README.md。项目的地址是: &lt;a href=&quot;https://github.com/dlundquist/sniproxy&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SNIProxy on GitHub&lt;/a&gt;。&lt;br&gt;我这里也提供一个打包好的 RPM 包，可直接通过 &lt;code&gt;yum&lt;/code&gt; 安装在 CentOS 7 上。下载地址为 &lt;a href=&quot;https://cloud.imvictor.tech/s/b8WqDWsJcrbgfLQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cloud Storage&lt;/a&gt;。  &lt;/p&gt;
&lt;h2 id=&quot;配置-SNIProxy&quot;&gt;&lt;a href=&quot;#配置-SNIProxy&quot; class=&quot;headerlink&quot; title=&quot;配置 SNIProxy&quot;&gt;&lt;/a&gt;配置 SNIProxy&lt;/h2&gt;&lt;p&gt;安装好包之后，SNIProxy 应该已经在 &lt;code&gt;/usr/sbin/sniproxy&lt;/code&gt; 了。&lt;br&gt;在大多数情况下，我们希望它作为一个服务启动，这样方便管理。但 SNIProxy 并没有把自己安装为服务，因此需要我们手动添加。&lt;br&gt;将以下内容放置到 &lt;code&gt;/etc/systemd/system/sniproxy.service&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-ini&quot;&gt;[Unit]
Description=SNIProxy

[Service]
Type=simple
ExecStart=/usr/sbin/sniproxy -f
StandardOutput=null
Restart=on-failure

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样就可以通过 &lt;code&gt;systemctl&lt;/code&gt; 来控制 SNIProxy 了。&lt;br&gt;然后我们需要编辑 SNIProxy 的配置文件 &lt;code&gt;/etc/sniproxy.conf&lt;/code&gt;，配置文件示例参见官方 README。 &lt;/p&gt;
&lt;p&gt;下面有几点小提示:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;注意，&lt;code&gt;listener&lt;/code&gt; 后面如果带有 &lt;code&gt;127.0.0.1&lt;/code&gt;，则只有本机才能传入连接。因此，一般推荐把 &lt;code&gt;listener 127.0.0.1:443&lt;/code&gt;，改为 &lt;code&gt;listener 443&lt;/code&gt;。 &lt;/li&gt;
&lt;li&gt;&lt;code&gt;fallback&lt;/code&gt; 参数的意思类似于 switch-case 语句的 &lt;code&gt;default&lt;/code&gt; 选项。即所有给出的情况全部失配后，选择将请求转发到这个参数所配置的服务器上。&lt;/li&gt;
&lt;li&gt;SNIProxy 也可以转发 HTTP 流量，只要把 &lt;code&gt;protocol&lt;/code&gt; 后面的 &lt;code&gt;tls&lt;/code&gt; 改成 &lt;code&gt;http&lt;/code&gt; 即可。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="/tags/Linux/"/>
    
      <category term="网站" scheme="/tags/%E7%BD%91%E7%AB%99/"/>
    
      <category term="网络" scheme="/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>FRP 作为 TCP 反向代理的部署</title>
    <link href="/posts/deploying-frp-reverse-proxy/"/>
    <id>/posts/deploying-frp-reverse-proxy/</id>
    <published>2018-07-16T14:00:27.000Z</published>
    <updated>2018-08-18T07:53:29.458Z</updated>
    
    <content type="html"><![CDATA[<p>最近发现经常出现 502 Bad Gateway，这让我很不爽，山河 OJ 刚刚火了不久，怎么就闹出这种事情来。<br>后来发现是 ZeroTier One 的锅，于是在 Menci 的建议下，采用 FRP 转发流量到家里的服务器。现在稍作记录，以备今后我自己查看和他人配置需要。</p><h3 id="双边配置"><a href="#双边配置" class="headerlink" title="双边配置"></a>双边配置</h3><p>首先执行 <code>wget https://github.com/fatedier/frp/releases/download/v0.20.0/frp_0.20.0_linux_amd64.tar.gz</code>，下载 frp。并解压。这里我们假定你的 frp 程序在 <code>/opt/frp/</code> 路径。</p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>首先服务器必须是有公网 IP 的。<br>修改 frps.ini 或者 frps_full.ini，这两个模板根据自己的情况修改，full 的那个更模板全一点。我的配置文件为 frps_full.ini。<br>下面详解一下常用各项的意思:</p><ul><li>bind_port 绑定的交流端口，和客户端一致即可。</li><li>bind_udp_port 打洞端口，没被占用、和 bind_port 不一致即可。</li><li>kcp_bind_port KCP 协议端口，可以和 bind_port 一致。</li><li>token 保证客户端和服务端一致，切勿泄露。</li><li>tcp_mux TCP 连接复用，建议设置为 <code>true</code>。</li></ul><p>在 <code>/etc/systemd/system/</code> 下创建 <code>frps.service</code>，内容请根据自己的实际情况修改:</p><pre><code>[Unit]Description=frps[Service]Type=simpleWorkingDirectory=/opt/frpExecStart=/opt/frp/frps -c /opt/frp/frps_full.iniStandardOutput=nullRestart=on-failure[Install]WantedBy=multi-user.target</code></pre><p><strong>请注意，frps 应当使用 root 用户启动。因为，在类 Unix 系统中，非 root 帐户不能绑定 1000 以下的端口。</strong><br>然后执行 <code>sudo systemctl enable frps.service &amp;&amp; sudo systemctl start frps.service</code>。</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>修改 frpc.ini 或者 frpc_full.ini，这两个模板根据自己的情况修改，full 的那个更模板全一点。我的配置文件为 frpc_full.ini。<br>下面详解一下常用各项的意思:</p><ul><li>server_addr 服务器地址，域名或 IP 都可。</li><li>server_port 与服务器的 bind_port 一致即可。</li><li>token 验证，与服务器的 token 一致即可。</li><li>tcp_mux 与服务器端效果相同</li><li>protocol 协议，默认 TCP。</li></ul><p>下面添加配置块，配置块的基本格式如下:</p><pre><code>[备注]type = 连接类型 (tcp / kcp)local_ip = 本地 IP (一般填写 127.0.0.1)local_port = 本地端口remote_port = 远程端口</code></pre><p>例如:</p><pre><code>[https]type = tcplocal_ip = 127.0.0.1local_port = 443remote_port = 443</code></pre><p>在 <code>/etc/systemd/system/</code> 下创建 <code>frpc.service</code>，内容请根据自己的实际情况修改:</p><pre><code>[Unit]Description=frpc[Service]Type=simpleWorkingDirectory=/opt/frpExecStart=/opt/frp/frpc -c /opt/frp/frpc_full.iniStandardOutput=nullRestart=on-failure[Install]WantedBy=multi-user.target</code></pre><p>然后执行 <code>sudo systemctl enable frpc.service &amp;&amp; sudo systemctl start frpc.service</code>。<br>这样，FRP 基本上就能充当一个合格的前端代理了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近发现经常出现 502 Bad Gateway，这让我很不爽，山河 OJ 刚刚火了不久，怎么就闹出这种事情来。&lt;br&gt;后来发现是 ZeroTier One 的锅，于是在 Menci 的建议下，采用 FRP 转发流量到家里的服务器。现在稍作记录，以备今后我自己查看和他人配置需要。&lt;/p&gt;
&lt;h3 id=&quot;双边配置&quot;&gt;&lt;a href=&quot;#双边配置&quot; class=&quot;headerlink&quot; title=&quot;双边配置&quot;&gt;&lt;/a&gt;双边配置&lt;/h3&gt;&lt;p&gt;首先执行 &lt;code&gt;wget https://github.com/fatedier/frp/releases/download/v0.20.0/frp_0.20.0_linux_amd64.tar.gz&lt;/code&gt;，下载 frp。并解压。这里我们假定你的 frp 程序在 &lt;code&gt;/opt/frp/&lt;/code&gt; 路径。&lt;/p&gt;
&lt;h3 id=&quot;服务端&quot;&gt;&lt;a href=&quot;#服务端&quot; class=&quot;headerlink&quot; title=&quot;服务端&quot;&gt;&lt;/a&gt;服务端&lt;/h3&gt;&lt;p&gt;首先服务器必须是有公网 IP 的。&lt;br&gt;修改 frps.ini 或者 frps_full.ini，这两个模板根据自己的情况修改，full 的那个更模板全一点。我的配置文件为 frps_full.ini。&lt;br&gt;下面详解一下常用各项的意思:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bind_port 绑定的交流端口，和客户端一致即可。&lt;/li&gt;
&lt;li&gt;bind_udp_port 打洞端口，没被占用、和 bind_port 不一致即可。&lt;/li&gt;
&lt;li&gt;kcp_bind_port KCP 协议端口，可以和 bind_port 一致。&lt;/li&gt;
&lt;li&gt;token 保证客户端和服务端一致，切勿泄露。&lt;/li&gt;
&lt;li&gt;tcp_mux TCP 连接复用，建议设置为 &lt;code&gt;true&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 &lt;code&gt;/etc/systemd/system/&lt;/code&gt; 下创建 &lt;code&gt;frps.service&lt;/code&gt;，内容请根据自己的实际情况修改:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[Unit]
Description=frps

[Service]
Type=simple
WorkingDirectory=/opt/frp
ExecStart=/opt/frp/frps -c /opt/frp/frps_full.ini
StandardOutput=null
Restart=on-failure

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;请注意，frps 应当使用 root 用户启动。因为，在类 Unix 系统中，非 root 帐户不能绑定 1000 以下的端口。&lt;/strong&gt;&lt;br&gt;然后执行 &lt;code&gt;sudo systemctl enable frps.service &amp;amp;&amp;amp; sudo systemctl start frps.service&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;客户端&quot;&gt;&lt;a href=&quot;#客户端&quot; class=&quot;headerlink&quot; title=&quot;客户端&quot;&gt;&lt;/a&gt;客户端&lt;/h3&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="/tags/Linux/"/>
    
      <category term="网站" scheme="/tags/%E7%BD%91%E7%AB%99/"/>
    
      <category term="网络" scheme="/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>推出 MakeGirlsMoe 镜像</title>
    <link href="/posts/mirrored-make-girls-moe/"/>
    <id>/posts/mirrored-make-girls-moe/</id>
    <published>2018-06-23T14:45:20.000Z</published>
    <updated>2018-06-23T14:43:46.172Z</updated>
    
    <content type="html"><![CDATA[<p>之前就看到了这个前端生成萌妹子头像的 WebApp，然后现在发现被 wall 了。那么我就尽一点绵薄之力，做个 Mirror。 ( 虽然我似乎没换过头像~</p><h3 id="地址-MakeGirlsMoe-镜像"><a href="#地址-MakeGirlsMoe-镜像" class="headerlink" title="地址: MakeGirlsMoe 镜像"></a>地址: <a href="https://make-girls.imvictor.tech" target="_blank" rel="noopener">MakeGirlsMoe 镜像</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前就看到了这个前端生成萌妹子头像的 WebApp，然后现在发现被 wall 了。那么我就尽一点绵薄之力，做个 Mirror。 ( 虽然我似乎没换过头像~&lt;/p&gt;
&lt;h3 id=&quot;地址-MakeGirlsMoe-镜像&quot;&gt;&lt;a href=&quot;#地址-MakeGirlsMoe-镜像&quot; class=&quot;headerlink&quot; title=&quot;地址: MakeGirlsMoe 镜像&quot;&gt;&lt;/a&gt;地址: &lt;a href=&quot;https://make-girls.imvictor.tech&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MakeGirlsMoe 镜像&lt;/a&gt;&lt;/h3&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SYZOJ2 在 CentOS 上的搭建</title>
    <link href="/posts/deploying-syzoj2-on-centos/"/>
    <id>/posts/deploying-syzoj2-on-centos/</id>
    <published>2018-06-14T15:12:20.000Z</published>
    <updated>2018-08-22T06:55:59.409Z</updated>
    
    <content type="html"><![CDATA[<p>这一个月倒是干了不少事，只是没找到时机记录下来。<br>前不久高爷带我去捡垃圾，弄到一台主机当服务器。<del>CPU 是 Pentium(R) Dual-Core E5700 @ 3.00GHz，想到比 BZOJ 还好一点，</del>现在换成了 Intel(R) Xeon(R)  CPU E5440 @ 2.83GHz，比 BZOJ 好多了。于是我就想搭建一个 OJ。<br>由于我对于 SYZOJ2 比较习惯，所以选择 SYZOJ2。<br>但是，SYZOJ2 官方只提供了 Ubuntu 的教程，在 CentOS 上，有些东西会不一样。<br>本文需要对照官方安装指南查看，详情请阅读 <a href="https://github.com/syzoj/syzoj/" target="_blank" rel="noopener">syzoj/syzoj on GitHub</a> 和 <a href="https://syzoj-demo.t123yh.xyz:20170/article/1" target="_blank" rel="noopener">Demo 服务器账号及搭建指南 - 帖子 - Demo</a>。<br>这里还有一篇很详细的 <a href="https://blog.masellum.me/2018/08/syzoj-setup/" target="_blank" rel="noopener">SYZOJ 部署指南</a>，是 Masellum 写的。值得参考。</p><h3 id="SYZOJ-Web"><a href="#SYZOJ-Web" class="headerlink" title="SYZOJ-Web"></a>SYZOJ-Web</h3><p>Web 的搭建相对比较简单。大部分都可以按照 SYZOJ2 官方的教程来做。<br>这里只说明不一样的地方。<br>对于在 Ubuntu 下的这段命令:</p><pre><code>apt install build-essential libboost1.58-all-dev nodejs rabbitmq-server redis-server nginx p7zip-full</code></pre><p>在 CentOS 上，首先，不能通过 yum 源安装 nodejs，因为 yum 源中的 nodejs 太古老，需要安装 8.0 版本(可能低一点也可以)。安装脚本如下:</p><pre><code class="lang-bash">curl --silent --location https://rpm.nodesource.com/setup_8.x | sudo bash -</code></pre><p>nginx 需要单独加源，方法自行搜索，很多。<br>剩下的包则用接下来的命令安装:</p><pre><code>yum groupinstall &quot;Development Tools&quot;yum install boost-devel rabbitmq-server redis p7zip p7zip-plugins</code></pre><p>其他步骤可以参照官方教程来进行。<br>另外，不清楚是不是 bug，如果在 config.json 中，将 <code>&quot;hostname&quot;</code> 字段设置为一个域名(这样注册验证电子邮件的地址就是这个域名)，那么必须在 <code>/etc/hosts</code> 中将这个域名的 IP 地址解析到 127.0.0.1，否则会无法启动 Web 端。</p><h3 id="SYZOJ-Judge"><a href="#SYZOJ-Judge" class="headerlink" title="SYZOJ-Judge"></a>SYZOJ-Judge</h3><p>Judge 端的情况，相对有一些问题。在 CentOS 上，出现了严重的问题，就是 C++ 程序默认是会 RE 的。经过我 chroot 到沙盒排查，这个问题是 <code>-mx32</code> 编译参数导致的。所以我们需要修改这个编译参数。<br>进入 Judge 文件夹，修改 <code>./src/languages/</code> 下的 <code>c.ts</code>、<code>cpp.ts</code>、<code>cpp11.ts</code>，将 <code>-mx32</code> 替换为空。<br>但这样会导致指针为 64 位大小，如果程序大量使用指针，可能导致 MLE，因为指针占据的空间是 32 位的两倍。因此，也可以把 <code>-mx32</code> 修改为 <code>-m32</code>，这样编译出来的是纯 32 位程序。<br>然后，在 Judge 文件夹下，执行 <code>npm run build</code> 重新编译评测程序。<br>此时，SYZOJ2 应当已经能够正常运行。<br>此外，给大家看一张图。<br><img src="https://static.imvictor.tech/data/201806/syzoj_bincache.jpg" alt="准备的大坑"><br>当时是在没有修改 <code>-mx32</code> 的时候提交了一道题，发现无论怎么重新评测，都是 RE。试了一晚上之后还是不行，最后我暴怒删题重加，发现奇迹般的行了。<br>询问 Menci 后得到的答复是，我成功跳进了 tyh 准备的大坑……<br>嗯，这坑很大。</p><h3 id="评测实时状态获取"><a href="#评测实时状态获取" class="headerlink" title="评测实时状态获取"></a>评测实时状态获取</h3><p>在 SYZOJ2 中浏览器在获取评测状态时，会尝试 SYZOJ-Web 的 <code>config.json</code> 中定义的 <code>&quot;judge_server_addr&quot;</code>。如果按照官方的配置将其配置为 <code>http://127.0.0.1:5284</code>，显然用户是不能访问的。<br>如果我们改成 OJ 的地址呢？在 CentOS 7 上，默认打开了防火墙，而防火墙默认会阻断 5284 端口。那么我们就有两种方案，一种是开放 5284 端口，但 SYZOJ-Frontend 监听下的 5284 端口不支持 HTTPS，导致 HTTPS 页面不能建立连接。综合来看，我们应当采用 nginx 反向代理来实现。这里提供配置文件参考。</p><pre><code class="lang-nginx">server {        listen 443 ssl http2;        listen [::]:443 ssl http2;        server_name 评测机域名;        location / {                proxy_set_header Host $http_host;                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;                proxy_set_header X-Forwarded-Proto $scheme;                proxy_set_header X-Real-IP $remote_addr;                proxy_pass http://127.0.0.1:5284;                client_max_body_size 0;        }    #error_page 404 = /404.html; error_page 403 = /403.html;        #ssl on;        ssl_certificate [cert];        ssl_certificate_key [key];}</code></pre><p>然后在 SYZOJ-Web 的 <code>config.json</code> 中将 <code>&quot;judge_server_addr&quot;</code> 的值修改为你设置的评测机域名。</p><h3 id="其他改动"><a href="#其他改动" class="headerlink" title="其他改动"></a>其他改动</h3><h4 id="服务文件修改"><a href="#服务文件修改" class="headerlink" title="服务文件修改"></a>服务文件修改</h4><p>你需要在所有 <code>syzoj-*.service</code> 中将 <code>redis-server.service</code> 替换成 <code>redis.service</code>。<br>如果你使用 MariaDB，请不要忘记在所有 <code>syzoj-*.service</code> 中将 <code>mysql.service</code> 替换成 <code>mariadb.service</code>。  </p><h4 id="Web-修改"><a href="#Web-修改" class="headerlink" title="Web 修改"></a>Web 修改</h4><p>默认的，全站管理员可以在 Web 管理后台中，查看和修改配置文件。这是不安全的。因为一旦任何一个全站管理员的 Cookie 或者密码泄露，就可能导致 secret 和 token 等敏感信息被查看。<br>备份一下 <code>[你的 SYZOJ-Web 程序目录]/views/admin_raw.ejs</code>，然后再建立一个新的 <code>admin_raw.ejs</code>，将以下内容写入:</p><pre><code class="lang-ejs">&lt;% this.adminPage = &#39;raw&#39;; %&gt;&lt;% include admin_header %&gt;&lt;p&gt;系统管理员已禁止从 Web 端修改配置文件.&lt;/p&gt;&lt;% include admin_footer %&gt;</code></pre><p>这样，配置文件就被限制为仅有拥有服务器 SSH 权限的人才能查看和修改的了。<br>如果你的数据库选用 <code>utf8mb4</code> 编码，可能遇到 <code>Unhandled rejection SequelizeDatabaseError: ER_TOO_LONG_KEY: Specified key was too long; max key length is 767 bytes</code> 的问题，这时你应当先用 root 权限登录 mysql，然后执行:</p><pre><code class="lang-sql">SET GLOBAL innodb_file_per_table = ON;SET GLOBAL innodb_large_prefix = ON;</code></pre><p>然后修改 <code>/etc/my.cnf</code> 加入以下语句:</p><pre><code class="lang-plain">default-storage-engine=INNODBinnodb_large_prefix=on</code></pre><hr><p>最后放一下 OJ 链接 <a href="https://mr.imvictor.tech/" target="_blank" rel="noopener">山河 OJ (Mountain &amp; River Online Judge)</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一个月倒是干了不少事，只是没找到时机记录下来。&lt;br&gt;前不久高爷带我去捡垃圾，弄到一台主机当服务器。&lt;del&gt;CPU 是 Pentium(R) Dual-Core E5700 @ 3.00GHz，想到比 BZOJ 还好一点，&lt;/del&gt;现在换成了 Intel(R) Xeon(R)  CPU E5440 @ 2.83GHz，比 BZOJ 好多了。于是我就想搭建一个 OJ。&lt;br&gt;由于我对于 SYZOJ2 比较习惯，所以选择 SYZOJ2。&lt;br&gt;但是，SYZOJ2 官方只提供了 Ubuntu 的教程，在 CentOS 上，有些东西会不一样。&lt;br&gt;本文需要对照官方安装指南查看，详情请阅读 &lt;a href=&quot;https://github.com/syzoj/syzoj/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;syzoj/syzoj on GitHub&lt;/a&gt; 和 &lt;a href=&quot;https://syzoj-demo.t123yh.xyz:20170/article/1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Demo 服务器账号及搭建指南 - 帖子 - Demo&lt;/a&gt;。&lt;br&gt;这里还有一篇很详细的 &lt;a href=&quot;https://blog.masellum.me/2018/08/syzoj-setup/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SYZOJ 部署指南&lt;/a&gt;，是 Masellum 写的。值得参考。&lt;/p&gt;
&lt;h3 id=&quot;SYZOJ-Web&quot;&gt;&lt;a href=&quot;#SYZOJ-Web&quot; class=&quot;headerlink&quot; title=&quot;SYZOJ-Web&quot;&gt;&lt;/a&gt;SYZOJ-Web&lt;/h3&gt;&lt;p&gt;Web 的搭建相对比较简单。大部分都可以按照 SYZOJ2 官方的教程来做。&lt;br&gt;这里只说明不一样的地方。&lt;br&gt;对于在 Ubuntu 下的这段命令:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apt install build-essential libboost1.58-all-dev nodejs rabbitmq-server redis-server nginx p7zip-full
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 CentOS 上，首先，不能通过 yum 源安装 nodejs，因为 yum 源中的 nodejs 太古老，需要安装 8.0 版本(可能低一点也可以)。安装脚本如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;curl --silent --location https://rpm.nodesource.com/setup_8.x | sudo bash -
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;nginx 需要单独加源，方法自行搜索，很多。&lt;br&gt;剩下的包则用接下来的命令安装:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;yum groupinstall &amp;quot;Development Tools&amp;quot;
yum install boost-devel rabbitmq-server redis p7zip p7zip-plugins
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其他步骤可以参照官方教程来进行。&lt;br&gt;另外，不清楚是不是 bug，如果在 config.json 中，将 &lt;code&gt;&amp;quot;hostname&amp;quot;&lt;/code&gt; 字段设置为一个域名(这样注册验证电子邮件的地址就是这个域名)，那么必须在 &lt;code&gt;/etc/hosts&lt;/code&gt; 中将这个域名的 IP 地址解析到 127.0.0.1，否则会无法启动 Web 端。&lt;/p&gt;
&lt;h3 id=&quot;SYZOJ-Judge&quot;&gt;&lt;a href=&quot;#SYZOJ-Judge&quot; class=&quot;headerlink&quot; title=&quot;SYZOJ-Judge&quot;&gt;&lt;/a&gt;SYZOJ-Judge&lt;/h3&gt;
    
    </summary>
    
    
      <category term="OI" scheme="/tags/OI/"/>
    
      <category term="Linux" scheme="/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>lemon 在 macOS 上的移植</title>
    <link href="/posts/lemon-mac/"/>
    <id>/posts/lemon-mac/</id>
    <published>2018-04-27T15:39:20.000Z</published>
    <updated>2018-09-15T08:24:35.587Z</updated>
    
    <content type="html"><![CDATA[<p>lemon 是一个轻量的 OI 评测系统。它基于 Qt 编写，因此应当具有强大的跨平台特性。<br>但是 2012 年开始，lemon 就不再更新了。而且之前官方也没有管 macOS 的问题，直接 qmake 也是不可能通过。<br>所以，我去做了一个移植的工作。<br>这里就直接贴项目地址了(其实就是骗 Star):<br><a href="https://github.com/lfVictor/lemon-mac" target="_blank" rel="noopener">lemon-mac 在 GitHub 上的内容</a></p><p>如果你实在懒得折腾，也可以下载我构建好的版本，既可以去 GitHub Release 下，也可以<a href="https://static.imvictor.tech/data/201809/lemon-darwin-x86_64.zip" target="_blank" rel="noopener">点击这里</a>下载。<br><img src="https://raw.githubusercontent.com/Chickking-Website/SomeFile/master/201804/lemon01.png" alt="lemon 界面"><br>放张图就跑~<br>另外，最近中国移动网络似乎会将 GitHub 解析到 127.0.0.1。访问不了 GitHub 的朋友们就去 Coding.net 吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;lemon 是一个轻量的 OI 评测系统。它基于 Qt 编写，因此应当具有强大的跨平台特性。&lt;br&gt;但是 2012 年开始，lemon 就不再更新了。而且之前官方也没有管 macOS 的问题，直接 qmake 也是不可能通过。&lt;br&gt;所以，我去做了一个移植的工作。&lt;br&gt;这里就直接贴项目地址了(其实就是骗 Star):&lt;br&gt;&lt;a href=&quot;https://github.com/lfVictor/lemon-mac&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;lemon-mac 在 GitHub 上的内容&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你实在懒得折腾，也可以下载我构建好的版本，既可以去 GitHub Release 下，也可以&lt;a href=&quot;https://static.imvictor.tech/data/201809/lemon-darwin-x86_64.zip&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击这里&lt;/a&gt;下载。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Chickking-Website/SomeFile/master/201804/lemon01.png&quot; alt=&quot;lemon 界面&quot;&gt;&lt;br&gt;放张图就跑~&lt;br&gt;另外，最近中国移动网络似乎会将 GitHub 解析到 127.0.0.1。访问不了 GitHub 的朋友们就去 Coding.net 吧。&lt;/p&gt;

    
    </summary>
    
    
      <category term="OI" scheme="/tags/OI/"/>
    
      <category term="macOS" scheme="/tags/macOS/"/>
    
      <category term="C++" scheme="/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>图的存储与遍历</title>
    <link href="/posts/save_graph_and_traversal_it/"/>
    <id>/posts/save_graph_and_traversal_it/</id>
    <published>2018-04-15T09:44:20.000Z</published>
    <updated>2018-08-18T07:53:29.461Z</updated>
    
    <content type="html"><![CDATA[<p>图的存储与一般有三种形式，邻接矩阵、邻接表、链式前向星（邻接表的一种）。<br>本文全文使用这个图来进行演示。<br><img src="https://raw.githubusercontent.com/Chickking-Website/SomeFile/master/201804/graph_test.png" alt="图示"><br>我们规定，一共有 $n$ 个点，$m$ 条边。输入数据的格式为 “起点”、“终点”、“边权”。则这个图的输入数据为: </p><pre><code class="lang-plain">1 2 21 4 32 3 12 5 33 1 25 3 25 4 4</code></pre><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>由于邻接矩阵空间消耗巨大，一般不使用。<br>邻接矩阵初始化时，我们使用无穷。<br>$\begin{bmatrix} \infty &amp; \infty &amp; \infty &amp; \infty &amp; \infty \\ \infty &amp; \infty &amp; \infty &amp; \infty &amp; \infty \\ \infty &amp; \infty &amp; \infty &amp; \infty &amp; \infty \\ \infty &amp; \infty &amp; \infty &amp; \infty &amp; \infty \\ \infty &amp; \infty &amp; \infty &amp; \infty &amp; \infty \end{bmatrix}$<br>因为对于有些题目，存在瞬移术，可以将某个权重的边跳过，这时可以把它的边权设为 0，这样就和不连通的情况产生了冲突，因此，就不能使用 0 为初值，当然，对于不存在这种情况的题目，仍可使用 0。<br>对于这个图，其邻接矩阵为：<br>$\begin{bmatrix} 0 &amp; 2 &amp; \infty &amp; 3 &amp; \infty \\ \infty &amp; 0 &amp; 1 &amp; \infty &amp; 3 \\ 2 &amp; \infty &amp; 0 &amp; \infty &amp; \infty \\ \infty &amp; \infty &amp; \infty &amp; 0 &amp; \infty \\ \infty &amp; \infty &amp; 2 &amp; 4 &amp; 0 \end{bmatrix}$<br>邻接矩阵的实质，就是用元素的有无来判断两个点是否连通。<br>因此，邻接矩阵的遍历效率很低，空间开销也很大，而且不能存储重边，可以存储自环(不过好像用处不大)。<br>建图、存储的时间复杂度为 $\text{O}(n^2)$ (若初始化为 $0$ 则为 $O(m)$ 的时间复杂度)，空间复杂度为 $\text{O}(n^2)$。<br>遍历的时间复杂度为 $\text{O}(n^2)$。<br>模板如下： </p><pre><code class="lang-cpp">#define INF LLONG_MAXtypedef long long ll;const int MAXN = 1000 + 1;ll adj_matrix[MAXN][MAXN]; // 邻接矩阵声明，若为不带权图，则可以将 long long 改为 bool.inline void addEdge(int prev, int next, ll w = 1) {   // 加边，默认为有向图，边权默认为 1，便于使用不带权图    adj_matrix[prev][next] = w;}void init(int maxn, bool is_zero = false) {     // 初始化    if (is_zero) return;                        // 若初始化为 0 则直接退出    for (int i = 1; i &lt;= maxn; i++)             // 外循环        for (int j = 1; j &lt;= maxn; j++) {       // 内循环            if (i == j) continue;               // 若起点终点则初始化为 0             adj_matrix[i][j] = INF;             // 否则初始化为无穷大        }}void read(int const m, bool directed = true, bool have_weight = true) { // m 为数据组数，即边数，directed 为是否有向，have_weight 为是否带权    int a = 0, b = 0, w = 1;                // 声明变量    for (int i = 1; i &lt;= m; i++) {          // 开始读入数据        scanf(&quot;%d %d&quot;, &amp;a, &amp;b);             // 读入        if (have_weight) scanf(&quot;%d&quot;, &amp;w);   // 若带权，就读入权值        addEdge(a, b, w);                   // 加边        if (!directed) addEdge(b, a, w);    // 若不带方向，即为无向图，添加反向边    }}void traversal(int amount_of_vertexes) {    // 遍历，传入参数为点数    for (int i = 1; i &lt;= amount_of_vertexes; i++)        for (int j = 1; j &lt;= amount_of_vertexes; j++) {            if (i == j) continue;            if (adj_matrix[i][j] != INF) ;  //操作一下        }}</code></pre><p>下面我们将介绍一种更加优越的存储方式。</p><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>邻接表，是一种十分神奇的东西，它的基本组成是节点数组和边链表。<br>像之前那个图，邻接表如下：<br><img src="https://raw.githubusercontent.com/Chickking-Website/SomeFile/master/201804/list_fixed.png" alt="邻接表"><br>根据输入可以发现，邻接表是一种<strong>动态</strong>存储方式。<br>邻接表的边是倒序存储的，也就是说，邻接表的构建和输入顺序是有关联的，但并不影响。<br>邻接表可以存储重边和自环。<br>事实上，边链表<strong>相对输入顺序</strong>，是<strong>倒序</strong>存储的。<br>显然，动态建图存储的时间、空间复杂度为 $\text{O}(m)$。<br>遍历的时间复杂度为 $\text{O}(m)$。<br>可以看出，因为邻接表使用了链表，因此内存管理是一个大问题，而且写起来也略微麻烦。<br>模板如下： </p><pre><code class="lang-cpp">typedef long long ll;const int MAXN = 1000 + 1;struct Node {    struct Edge *firstEdge;     // 第一条边 (事实上是最后一条边，因为倒序)    Node() {        firstEdge = NULL;       // 设置指针初值为空    }} Graph[MAXN];struct Edge {    Node *prev, *next;          // 前驱点、后继点    ll w;                       // 权值    Edge *nextEdge;             // 下一条边 (事实上是上一条边，因为倒序)    Edge(Node *const &amp;prev, Node *const &amp;next, const ll &amp;w) : prev(prev), next(next), w(w), nextEdge(prev-&gt;firstEdge) {}    // 构造函数，利用 initializer list，自动设置 nextEdge 为下(事实上为上)一条边。};inline void addEdge(int prev, int next, ll w = 1) {   // 添加边，默认有向，边权 w 默认为 1，便于使用不带权图    Graph[prev].firstEdge = new Edge (&amp;Graph[prev], &amp;Graph[next], w);}void read(int const m, bool directed = true, bool have_weight = true) { // m 为数据组数，即边数，directed 为是否有向，have_weight 为是否带权    int a = 0, b = 0, w = 1;                // 声明变量    for (int i = 1; i &lt;= m; i++) {          // 开始读入数据        scanf(&quot;%d %d&quot;, &amp;a, &amp;b);             // 读入        if (have_weight) scanf(&quot;%d&quot;, &amp;w);   // 若带权，就读入权值        addEdge(a, b, w);                   // 加边        if (!directed) addEdge(b, a, w);    // 若不带方向，即为无向图，添加反向边    }}void traversal(int amount_of_vertexes) {    // 遍历，传入参数为点数    for (int i = 1; i &lt;= amount_of_vertexes; i++) {        for (Edge* e = Graph[i].firstEdge; e != NULL; e = e-&gt;nextEdge) {            /*e-&gt;next ...;            e-&gt;prev ...;            ...*/ // 此处可以操作        }    }}</code></pre><p>前方高能预警。</p><h3 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h3><p>链式前向星是一种更加<del>神奇</del>优越的存储方式。<br>链式前向星的结构为一个点信息数组，一个边信息结构体数组，一个当前处理边的编号计数器。其核心思想是给边编号，这样就能方便地用数组存储了。<br>链式前向星也可以存储重边和自环。<br>链式前向星使用了数组来模拟链表，这样就避免了复杂的内存管理。而它是一种类似邻接表的存储方式，因此，也具有空间复杂度低，时间复杂度低的特性。<br>显然，由于读入完成则建图完成，建图的时间复杂度为 $\text{O}(m)$，存储的空间复杂度为 $\text{O}(n+m)$。<br>遍历的时间复杂度应该为 $\text{O}(m)$ (个人分析，如有误请指正)。<br>根据我们的输入，点信息数组 head 的值为：  </p><pre><code class="lang-plain">下标：1 2 3 4 5数据：2 4 5 0 7</code></pre><p>边信息数组中的信息如下： </p><pre><code class="lang-cpp">edges[1].next = 2 ; edges[1].w = 2 ; edges[1].nextEdge = 0edges[2].next = 4 ; edges[2].w = 3 ; edges[2].nextEdge = 1edges[3].next = 3 ; edges[3].w = 1 ; edges[3].nextEdge = 0edges[4].next = 5 ; edges[4].w = 3 ; edges[4].nextEdge = 3edges[5].next = 1 ; edges[5].w = 2 ; edges[5].nextEdge = 0edges[6].next = 3 ; edges[6].w = 2 ; edges[6].nextEdge = 0edges[7].next = 4 ; edges[7].w = 4 ; edges[7].nextEdge = 6</code></pre><p>模板如下： </p><pre><code class="lang-cpp">const int MAXN = 1000, MAXM = 2000;int head[MAXN];     // 存储点的信息int edge_count;     // 当前处理的边的编号struct Edge {    int prev, next, nextEdge;   // 前驱、后继、下一条边    long long w;                // 边权值} edges[MAXM];void addEdge(int const a, int const b, int w = 1) {    edges[++edge_count].prev = a;   // 设置前驱点为起点 a，++edge_count 令当前处理的边的编号 +1    edges[edge_count].next = b;     // 设置后继点为终点 b    edges[edge_count].w = w;        // 设置边权    edges[edge_count].nextEdge = head[a];   // 从点信息数组 head 中取出下一条边的编号，若当前为第一条边则取出初值 0    head[a] = edge_count;           // 记录当前的边编号到点信息数组 head 中，为下一条边的增添做准备}void read(int const m, bool directed = true, bool have_weight = true) { // m 为数据组数，即边数，directed 为是否有向，have_weight 为是否带权    int a = 0, b = 0, w = 1;                // 声明变量    for (int i = 1; i &lt;= m; i++) {          // 开始读入数据        scanf(&quot;%d %d&quot;, &amp;a, &amp;b);             // 读入        if (have_weight) scanf(&quot;%d&quot;, &amp;w);   // 若带权，就读入权值        addEdge(a, b, w);                   // 加边        if (!directed) addEdge(b, a, w);    // 若不带方向，即为无向图，添加反向边    }}void traversal(int const n) {               // n 为点数    for (int i = 1; i &lt;= n; i++) {          // 从第 1 个点开始遍历        for (int k = head[i]; k; k = edges[k].nextEdge) { // 令 k 为第 1 条边，直到最后一条边，当 k 到达最后一条边时为 0，结束遍历。            // do something.        }    }}</code></pre><p>事实上，除了不能像邻接矩阵那样直接判断两个点之间是否连通，链式前向星几乎是完美的。<br>在实际应用中，也可以根据题目读入的数据，通过动态数组来做，能够进一步优化空间开销。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;图的存储与一般有三种形式，邻接矩阵、邻接表、链式前向星（邻接表的一种）。&lt;br&gt;本文全文使用这个图来进行演示。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Chickking-Website/SomeFile/master/201804/graph_test.png&quot; alt=&quot;图示&quot;&gt;&lt;br&gt;我们规定，一共有 $n$ 个点，$m$ 条边。输入数据的格式为 “起点”、“终点”、“边权”。则这个图的输入数据为: &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-plain&quot;&gt;1 2 2
1 4 3
2 3 1
2 5 3
3 1 2
5 3 2
5 4 4
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;邻接矩阵&quot;&gt;&lt;a href=&quot;#邻接矩阵&quot; class=&quot;headerlink&quot; title=&quot;邻接矩阵&quot;&gt;&lt;/a&gt;邻接矩阵&lt;/h3&gt;&lt;p&gt;由于邻接矩阵空间消耗巨大，一般不使用。&lt;br&gt;邻接矩阵初始化时，我们使用无穷。&lt;br&gt;$\begin{bmatrix} \infty &amp;amp; \infty &amp;amp; \infty &amp;amp; \infty &amp;amp; \infty \\ \infty &amp;amp; \infty &amp;amp; \infty &amp;amp; \infty &amp;amp; \infty \\ \infty &amp;amp; \infty &amp;amp; \infty &amp;amp; \infty &amp;amp; \infty \\ \infty &amp;amp; \infty &amp;amp; \infty &amp;amp; \infty &amp;amp; \infty \\ \infty &amp;amp; \infty &amp;amp; \infty &amp;amp; \infty &amp;amp; \infty \end{bmatrix}$&lt;br&gt;因为对于有些题目，存在瞬移术，可以将某个权重的边跳过，这时可以把它的边权设为 0，这样就和不连通的情况产生了冲突，因此，就不能使用 0 为初值，当然，对于不存在这种情况的题目，仍可使用 0。&lt;br&gt;对于这个图，其邻接矩阵为：&lt;br&gt;$\begin{bmatrix} 0 &amp;amp; 2 &amp;amp; \infty &amp;amp; 3 &amp;amp; \infty \\ \infty &amp;amp; 0 &amp;amp; 1 &amp;amp; \infty &amp;amp; 3 \\ 2 &amp;amp; \infty &amp;amp; 0 &amp;amp; \infty &amp;amp; \infty \\ \infty &amp;amp; \infty &amp;amp; \infty &amp;amp; 0 &amp;amp; \infty \\ \infty &amp;amp; \infty &amp;amp; 2 &amp;amp; 4 &amp;amp; 0 \end{bmatrix}$&lt;br&gt;邻接矩阵的实质，就是用元素的有无来判断两个点是否连通。&lt;br&gt;因此，邻接矩阵的遍历效率很低，空间开销也很大，而且不能存储重边，可以存储自环(不过好像用处不大)。&lt;br&gt;建图、存储的时间复杂度为 $\text{O}(n^2)$ (若初始化为 $0$ 则为 $O(m)$ 的时间复杂度)，空间复杂度为 $\text{O}(n^2)$。&lt;br&gt;遍历的时间复杂度为 $\text{O}(n^2)$。&lt;br&gt;模板如下： &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;#define INF LLONG_MAX
typedef long long ll;
const int MAXN = 1000 + 1;

ll adj_matrix[MAXN][MAXN]; // 邻接矩阵声明，若为不带权图，则可以将 long long 改为 bool.

inline void addEdge(int prev, int next, ll w = 1) {   // 加边，默认为有向图，边权默认为 1，便于使用不带权图
    adj_matrix[prev][next] = w;
}

void init(int maxn, bool is_zero = false) {     // 初始化
    if (is_zero) return;                        // 若初始化为 0 则直接退出
    for (int i = 1; i &amp;lt;= maxn; i++)             // 外循环
        for (int j = 1; j &amp;lt;= maxn; j++) {       // 内循环
            if (i == j) continue;               // 若起点终点则初始化为 0 
            adj_matrix[i][j] = INF;             // 否则初始化为无穷大
        }
}

void read(int const m, bool directed = true, bool have_weight = true) { // m 为数据组数，即边数，directed 为是否有向，have_weight 为是否带权
    int a = 0, b = 0, w = 1;                // 声明变量
    for (int i = 1; i &amp;lt;= m; i++) {          // 开始读入数据
        scanf(&amp;quot;%d %d&amp;quot;, &amp;amp;a, &amp;amp;b);             // 读入
        if (have_weight) scanf(&amp;quot;%d&amp;quot;, &amp;amp;w);   // 若带权，就读入权值
        addEdge(a, b, w);                   // 加边
        if (!directed) addEdge(b, a, w);    // 若不带方向，即为无向图，添加反向边
    }
}

void traversal(int amount_of_vertexes) {    // 遍历，传入参数为点数
    for (int i = 1; i &amp;lt;= amount_of_vertexes; i++)
        for (int j = 1; j &amp;lt;= amount_of_vertexes; j++) {
            if (i == j) continue;
            if (adj_matrix[i][j] != INF) ;  //操作一下
        }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面我们将介绍一种更加优越的存储方式。&lt;/p&gt;
&lt;h3 id=&quot;邻接表&quot;&gt;&lt;a href=&quot;#邻接表&quot; class=&quot;headerlink&quot; title=&quot;邻接表&quot;&gt;&lt;/a&gt;邻接表&lt;/h3&gt;&lt;p&gt;邻接表，是一种十分神奇的东西，它的基本组成是节点数组和边链表。&lt;br&gt;像之前那个图，邻接表如下：&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Chickking-Website/SomeFile/master/201804/list_fixed.png&quot; alt=&quot;邻接表&quot;&gt;&lt;br&gt;根据输入可以发现，邻接表是一种&lt;strong&gt;动态&lt;/strong&gt;存储方式。&lt;br&gt;邻接表的边是倒序存储的，也就是说，邻接表的构建和输入顺序是有关联的，但并不影响。&lt;br&gt;邻接表可以存储重边和自环。&lt;br&gt;事实上，边链表&lt;strong&gt;相对输入顺序&lt;/strong&gt;，是&lt;strong&gt;倒序&lt;/strong&gt;存储的。&lt;br&gt;显然，动态建图存储的时间、空间复杂度为 $\text{O}(m)$。&lt;br&gt;遍历的时间复杂度为 $\text{O}(m)$。&lt;br&gt;可以看出，因为邻接表使用了链表，因此内存管理是一个大问题，而且写起来也略微麻烦。&lt;br&gt;模板如下： &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;typedef long long ll;
const int MAXN = 1000 + 1;

struct Node {
    struct Edge *firstEdge;     // 第一条边 (事实上是最后一条边，因为倒序)
    Node() {
        firstEdge = NULL;       // 设置指针初值为空
    }
} Graph[MAXN];
struct Edge {
    Node *prev, *next;          // 前驱点、后继点
    ll w;                       // 权值
    Edge *nextEdge;             // 下一条边 (事实上是上一条边，因为倒序)

    Edge(Node *const &amp;amp;prev, Node *const &amp;amp;next, const ll &amp;amp;w) : prev(prev), next(next), w(w), nextEdge(prev-&amp;gt;firstEdge) {}    // 构造函数，利用 initializer list，自动设置 nextEdge 为下(事实上为上)一条边。
};

inline void addEdge(int prev, int next, ll w = 1) {   // 添加边，默认有向，边权 w 默认为 1，便于使用不带权图
    Graph[prev].firstEdge = new Edge (&amp;amp;Graph[prev], &amp;amp;Graph[next], w);
}

void read(int const m, bool directed = true, bool have_weight = true) { // m 为数据组数，即边数，directed 为是否有向，have_weight 为是否带权
    int a = 0, b = 0, w = 1;                // 声明变量
    for (int i = 1; i &amp;lt;= m; i++) {          // 开始读入数据
        scanf(&amp;quot;%d %d&amp;quot;, &amp;amp;a, &amp;amp;b);             // 读入
        if (have_weight) scanf(&amp;quot;%d&amp;quot;, &amp;amp;w);   // 若带权，就读入权值
        addEdge(a, b, w);                   // 加边
        if (!directed) addEdge(b, a, w);    // 若不带方向，即为无向图，添加反向边
    }
}

void traversal(int amount_of_vertexes) {    // 遍历，传入参数为点数
    for (int i = 1; i &amp;lt;= amount_of_vertexes; i++) {
        for (Edge* e = Graph[i].firstEdge; e != NULL; e = e-&amp;gt;nextEdge) {
            /*e-&amp;gt;next ...;
            e-&amp;gt;prev ...;
            ...*/ // 此处可以操作
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;前方高能预警。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI" scheme="/tags/OI/"/>
    
      <category term="算法模板" scheme="/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="图论" scheme="/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>欧几里得算法、欧拉筛模板</title>
    <link href="/posts/exgcd_and_euler_sieve_template/"/>
    <id>/posts/exgcd_and_euler_sieve_template/</id>
    <published>2018-04-06T11:02:20.000Z</published>
    <updated>2018-08-18T07:53:29.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h2><pre><code class="lang-cpp">int gcd(int const a, int const b) {    return !b ? a : gcd(b, a % b);}int lcm(int const a, int const b) {    return a / gcd(a, b) * b;}int exgcd(int const a, int const b, int &amp;x, int &amp;y) {    int ans = a;    if (b == 0) {        x = 1, y = 0;        return ans;    }    else {        ans = exgcd(b, a % b, y, x);        y -= x * (a / b);        return ans;    }}</code></pre><h2 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h2><pre><code class="lang-cpp">bool is_prime[MAXN];int primes[MAXN], query[MAXM];int n, m, p;void sieve(int const n) {    memset(primes, 0, sizeof(primes));    memset(is_prime, 1, sizeof(is_prime));    is_prime[1] = false;    for (int i = 2; i &lt;= n; i++) {        if (is_prime[i]) {            primes[p++] = i;        }        for (int j = 0; j &lt; p &amp;&amp; i * primes[j] &lt;= n; j++) {            is_prime[ i * primes[j] ] = false;            if (! (i % primes[j]) )                break;        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;扩展欧几里得&quot;&gt;&lt;a href=&quot;#扩展欧几里得&quot; class=&quot;headerlink&quot; title=&quot;扩展欧几里得&quot;&gt;&lt;/a&gt;扩展欧几里得&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;int gcd(int const a, int const b) {
    return !b ? a : gcd(b, a % b);
}

int lcm(int const a, int const b) {
    return a / gcd(a, b) * b;
}

int exgcd(int const a, int const b, int &amp;amp;x, int &amp;amp;y) {
    int ans = a;
    if (b == 0) {
        x = 1, y = 0;
        return ans;
    }
    else {
        ans = exgcd(b, a % b, y, x);
        y -= x * (a / b);
        return ans;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;欧拉筛&quot;&gt;&lt;a href=&quot;#欧拉筛&quot; class=&quot;headerlink&quot; title=&quot;欧拉筛&quot;&gt;&lt;/a&gt;欧拉筛&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;bool is_prime[MAXN];
int primes[MAXN], query[MAXM];
int n, m, p;

void sieve(int const n) {
    memset(primes, 0, sizeof(primes));
    memset(is_prime, 1, sizeof(is_prime));
    is_prime[1] = false;
    for (int i = 2; i &amp;lt;= n; i++) {
        if (is_prime[i]) {
            primes[p++] = i;
        }
        for (int j = 0; j &amp;lt; p &amp;amp;&amp;amp; i * primes[j] &amp;lt;= n; j++) {
            is_prime[ i * primes[j] ] = false;
            if (! (i % primes[j]) )
                break;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

    
    </summary>
    
    
      <category term="OI" scheme="/tags/OI/"/>
    
      <category term="数论" scheme="/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="算法模板" scheme="/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>2018 NOIP 青岛冬令营行记</title>
    <link href="/posts/2018-noip-winter-campus-in-qingdao/"/>
    <id>/posts/2018-noip-winter-campus-in-qingdao/</id>
    <published>2018-02-13T05:08:26.000Z</published>
    <updated>2018-08-18T07:53:29.455Z</updated>
    
    <content type="html"><![CDATA[<p>第一次参加这种集训呢……<br>也许我退役之后，会更加怀念这段时光呢。</p><h3 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h3><p>从临沂到青岛的路上真心体会到了车内缺氧的环境有多么的可啪，头晕晕的 qwq……<br>路上看到工厂冒出来的浓浓的白烟，真心感觉我们国家的环境保护还是有点不够。虽然不是黑烟了，但是那里的天空的颜色都已经失去了原本的蓝色。<br><img src="https://raw.githubusercontent.com/Chickking-Website/SomeFile/master/201802/smoke.jpeg" alt="Smoke"><br>Day 0 也就是正式开始的前一天，被老唐指定为组长还是挺有意思的，只是没有想到组长的活竟然这么麻烦。<br>在海大的学术交流中心里面住宿。分套房的时候是让自己分的哇，必须好评！和 dzy 两人住一间屋甚是愉快啊！</p><h3 id="Day-1-Day-2"><a href="#Day-1-Day-2" class="headerlink" title="Day 1 ~ Day 2"></a>Day 1 ~ Day 2</h3><p>Day 1 和 Day 2 的主讲老师是清华的 <a href="https://github.com/haoxizhong" target="_blank" rel="noopener">zhx</a>，人称钟长者。钟长者还是很有意思的一个人啊。Day 1 晚上考了场试，这场试钟长者出的题还是很良心的。我成功地骗到了不少分。我自己也想不到在这里 130 多个人里面能拿到第五名哎(๑•ᴗ•๑)。<br><img src="https://raw.githubusercontent.com/Chickking-Website/SomeFile/master/201802/day1_test.png" alt="Result"><br>所以说还是钟长者比较 6 啊，随随便便 AK。<br>钟长者是个很皮的人，比如:</p><pre><code class="lang-cpp">void two_fen_cha_zhao();</code></pre><p>Day 1 发生了一件非常恐怖的事情，教室里出现了一个 Wi-Fi:<br><img src="https://raw.githubusercontent.com/Chickking-Website/SomeFile/master/201802/scary_wifi.jpeg" alt="Scary Wi-Fi"><br>我感觉这个可能会让全教室的人死光。<br>Day 2 晚上发生了一件很槽的事，老唐把集训队的手机全部收走了，iPhone SE 便离我远去了 qwq。</p><h3 id="Day-3-Day-4"><a href="#Day-3-Day-4" class="headerlink" title="Day 3 ~ Day 4"></a>Day 3 ~ Day 4</h3><p>Day 3 和 Day 4 的主讲老师是北大的 zhw。果然清北圣战永不停息啊。<br>感觉从 Day 3 开始就有点颓了。zhw 给我的感受就是这个人绝对是浪着上北大的。发张表情包瞅瞅😂:<br><img src="https://github.com/Chickking-Website/SomeFile/blob/master/201802/zhw1.jpg?raw=true" alt="zhw"><br>我想这可能是个被 OI 耽误了的电竞选手吧。但更神奇的是他能在 $26 \space\mathrm{s}$ 之内解决 $4 \times 4$ 的数字华容道啊。<br>因为没有了手机，Day 3 的时候我手写了一个闹钟，学的 C++ 倒是管用了。<br>如果谁的手机也被收了可以自取了，顺便可以帮我把代码改得好一点。<a href="https://pan.baidu.com/s/1ghestdL" target="_blank" rel="noopener">闹钟</a><br>Day 3 晚上鼓捣了一晚上的 Ubuntu。让它能够用 Wine 跑炉石了，感觉很妙。<br>话说集训班班主任真的好帅，而且人真的好好啊。听说我们一中集训队的手机被收了还和老唐沟通，虽然没要回来但是心意真的到了啊，中国好班主任。<br>我发现这些神犇老师都喜欢甩锅，前面的把锅甩给后面的。后面的 dzj 会发现树状数组什么的锅都已经扣到了他的头上，真是“人从家里坐，锅从天上来”。<br>Day 4 晚上给我的 Mac 换了个壁纸，感觉很开心。不过我有点搞不懂最近为什么有人说我有点女生特质……蛤？壁纸控有什么问题吗？<br><img src="https://raw.githubusercontent.com/Chickking-Website/SomeFile/master/201802/new_wallpaper.png" alt="Wallpaper"><br><em>原图被 QQ 空间压缩的不能看，这张后补。</em><br>晚上还发生了一件恐怖的事情，我们忘记了栓门。dzy 在 22:40 左右刚刚打开游戏想玩几分钟，我在床上抱着 Mac 欣赏刚换的壁纸。结果老唐拿着万能房卡闯了进来，后面的事情就不用多说了，还好只是训一顿。</p><h3 id="Day-5-Day-6"><a href="#Day-5-Day-6" class="headerlink" title="Day 5 ~ Day 6"></a>Day 5 ~ Day 6</h3><p>今天的老师就是北大的 dzj 了。dzj 感觉好像比那两个大邪子神犇要老实的多。<br>总感觉 zhx 和 dzj 有某种奇妙的关系，因为群里出现了两个 dzj:<br><img src="https://github.com/Chickking-Website/SomeFile/blob/master/201802/fake_dzj.png?raw=true" alt="fake_dzj"><br>下面那个其实是 zhx 蛤蛤蛤蛤~<br>Day 5 开始就真的是颓的没边了，DP 和图论都没怎么听懂。Day 6 晚上要考试，然而我在 dalao <a href="https://github.com/Menci/" target="_blank" rel="noopener">@Menci</a> 的 OJ 上看到了这个:<br><img src="https://raw.githubusercontent.com/Chickking-Website/SomeFile/master/201802/bad_luck.png" alt="bad_luck"><br>我瞬间感觉一丝不妙，所以到了晚上……<br><strong>dzj 出的题真 TM 难骗分，还是说我今天就该爆零？</strong><br>本来以为能对一题，结果没想到，三题全错，爆零。<br>Menci 大佬您的程序成精了，这个是真的神预测。<br>老铁 ybx 鼓励了我一晚上，然而天命难违……<br><img src="https://raw.githubusercontent.com/Chickking-Website/SomeFile/master/201802/22CECC04-198D-4296-B5CA-EFE81426324F.jpeg" alt="ybx 好棒"><br><em>(感觉这种公开博客还是不要出现身边人的完全人名的好。)</em><br>说起来也真是“天道好轮回，苍天饶过谁”。当年把 DFS 写的一溜一溜的，还去教 zms 写 DFS，然而今天我自己写不出来 DFS 了，明明全排列我在洛谷上已经 A 掉了啊，就是写不出来 qwq。<br>这哪儿还有脸说她的 DFS 是我教的，而且人家最后没爆零。<br>成绩一出，四面凉凉。我直接开了满音量放凉凉(～￣▽￣)～。<br>话说我们的群都快变成红包群了:<br><img src="https://github.com/Chickking-Website/SomeFile/blob/master/201802/屏幕快照%202018-02-13%20上午12.15.58.png?raw=true" alt="zhx_zhw"><br>其实 dzj 发的红包还是不少的。<br><img src="https://github.com/Chickking-Website/SomeFile/blob/master/201802/dzj.png?raw=true" alt="dzj_money"></p><h3 id="Day-7"><a href="#Day-7" class="headerlink" title="Day 7"></a>Day 7</h3><p>早上老唐终于把手机还给大家啦，于是锅底在群里发口令红包“庆祝手机回来啦”。<br>然而 zhw 好毒瘤啊，抢完红包就撤回……<br>今天上午讲一些 NOIP 的题目，但是可能因为是最后一天吧，大家都有点颓。<br>不过 dzj 最后也装不下去了，开始讲段子了蛤蛤蛤蛤~<br>到最后一天才知道原来 dzj 是这样一个污污污的人啊。什么叫讲的段子污到我都听不懂。还说“听得懂的同学有些不检点啊”。<br>咦？dzj 好像暴露了什么 (滑稽<br>据 dzj 自己说，他一进群发现已经有一个“湖南师范大学附属中学段志健”的时候，他是一脸懵逼的。<br>后来一看头像，才认出原来是 zhx 伪装的。<br>话说 dzj 是不是应该思考一下为什么 zhx 不伪装成 zhw 偏偏要伪装成他呢蛤蛤蛤蛤~<br>不过说真的，我直到最后一天才发现原来班主任才是冬令营第一大帅哥哇。<br><img src="https://raw.githubusercontent.com/Chickking-Website/SomeFile/master/201802/ksb_handsome.jpeg" alt="Headteacher_so_handsome"><br>而且班主任也有可(gao)爱(xiao)的一面哟。<br><img src="https://raw.githubusercontent.com/Chickking-Website/SomeFile/master/201802/屏幕快照%202018-02-13%20下午12.43.13.png" alt="Headteacher&#39;s Moe"><br>2333333...<br>最后一天了，于是我给教室里的 ThinkPad 和我的 MacBook Pro 来了一张合照(虽然那台小 TP 很喜欢蓝屏但是我还是很感谢它啊)。<br><img src="https://raw.githubusercontent.com/Chickking-Website/SomeFile/master/201802/mac_tp_picture.jpeg" alt="Picture_of_Mac_and_ThinkPad"><br><em>你们以为我这种桌面控/壁纸控会放过任何一台我用的电脑吗？既然要和它一起度过这些天，我肯定要把它打扮的漂亮一点啊(๑•ᴗ•๑)</em><br>现在我们就正在向临沂进发了！这一个星期真的很充实啊。<br><em>PS: dzy 在车上睡得好香 (逃</em>  </p><h3 id="Ending"><a href="#Ending" class="headerlink" title="Ending"></a>Ending</h3><p>青岛之行还是很充实哒，虽然很多东西都听得一懵一懵的，不过我相信我会变的越来越好，今后如果再来到这里，相信绝对比箭头的我更好。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一次参加这种集训呢……&lt;br&gt;也许我退役之后，会更加怀念这段时光呢。&lt;/p&gt;
&lt;h3 id=&quot;Day-0&quot;&gt;&lt;a href=&quot;#Day-0&quot; class=&quot;headerlink&quot; title=&quot;Day 0&quot;&gt;&lt;/a&gt;Day 0&lt;/h3&gt;&lt;p&gt;从临沂到青岛的路上真心体会到了车内缺氧的环境有多么的可啪，头晕晕的 qwq……&lt;br&gt;路上看到工厂冒出来的浓浓的白烟，真心感觉我们国家的环境保护还是有点不够。虽然不是黑烟了，但是那里的天空的颜色都已经失去了原本的蓝色。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Chickking-Website/SomeFile/master/201802/smoke.jpeg&quot; alt=&quot;Smoke&quot;&gt;&lt;br&gt;Day 0 也就是正式开始的前一天，被老唐指定为组长还是挺有意思的，只是没有想到组长的活竟然这么麻烦。&lt;br&gt;在海大的学术交流中心里面住宿。分套房的时候是让自己分的哇，必须好评！和 dzy 两人住一间屋甚是愉快啊！&lt;/p&gt;
&lt;h3 id=&quot;Day-1-Day-2&quot;&gt;&lt;a href=&quot;#Day-1-Day-2&quot; class=&quot;headerlink&quot; title=&quot;Day 1 ~ Day 2&quot;&gt;&lt;/a&gt;Day 1 ~ Day 2&lt;/h3&gt;&lt;p&gt;Day 1 和 Day 2 的主讲老师是清华的 &lt;a href=&quot;https://github.com/haoxizhong&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;zhx&lt;/a&gt;，人称钟长者。钟长者还是很有意思的一个人啊。Day 1 晚上考了场试，这场试钟长者出的题还是很良心的。我成功地骗到了不少分。我自己也想不到在这里 130 多个人里面能拿到第五名哎(๑•ᴗ•๑)。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Chickking-Website/SomeFile/master/201802/day1_test.png&quot; alt=&quot;Result&quot;&gt;&lt;br&gt;所以说还是钟长者比较 6 啊，随随便便 AK。&lt;br&gt;钟长者是个很皮的人，比如:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;void two_fen_cha_zhao();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Day 1 发生了一件非常恐怖的事情，教室里出现了一个 Wi-Fi:&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Chickking-Website/SomeFile/master/201802/scary_wifi.jpeg&quot; alt=&quot;Scary Wi-Fi&quot;&gt;&lt;br&gt;我感觉这个可能会让全教室的人死光。&lt;br&gt;Day 2 晚上发生了一件很槽的事，老唐把集训队的手机全部收走了，iPhone SE 便离我远去了 qwq。&lt;/p&gt;
&lt;h3 id=&quot;Day-3-Day-4&quot;&gt;&lt;a href=&quot;#Day-3-Day-4&quot; class=&quot;headerlink&quot; title=&quot;Day 3 ~ Day 4&quot;&gt;&lt;/a&gt;Day 3 ~ Day 4&lt;/h3&gt;&lt;p&gt;Day 3 和 Day 4 的主讲老师是北大的 zhw。果然清北圣战永不停息啊。&lt;br&gt;感觉从 Day 3 开始就有点颓了。zhw 给我的感受就是这个人绝对是浪着上北大的。发张表情包瞅瞅😂:&lt;br&gt;&lt;img src=&quot;https://github.com/Chickking-Website/SomeFile/blob/master/201802/zhw1.jpg?raw=true&quot; alt=&quot;zhw&quot;&gt;&lt;br&gt;我想这可能是个被 OI 耽误了的电竞选手吧。但更神奇的是他能在 $26 \space\mathrm{s}$ 之内解决 $4 \times 4$ 的数字华容道啊。&lt;br&gt;因为没有了手机，Day 3 的时候我手写了一个闹钟，学的 C++ 倒是管用了。&lt;br&gt;如果谁的手机也被收了可以自取了，顺便可以帮我把代码改得好一点。&lt;a href=&quot;https://pan.baidu.com/s/1ghestdL&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;闹钟&lt;/a&gt;&lt;br&gt;Day 3 晚上鼓捣了一晚上的 Ubuntu。让它能够用 Wine 跑炉石了，感觉很妙。&lt;br&gt;话说集训班班主任真的好帅，而且人真的好好啊。听说我们一中集训队的手机被收了还和老唐沟通，虽然没要回来但是心意真的到了啊，中国好班主任。&lt;br&gt;我发现这些神犇老师都喜欢甩锅，前面的把锅甩给后面的。后面的 dzj 会发现树状数组什么的锅都已经扣到了他的头上，真是“人从家里坐，锅从天上来”。&lt;br&gt;Day 4 晚上给我的 Mac 换了个壁纸，感觉很开心。不过我有点搞不懂最近为什么有人说我有点女生特质……蛤？壁纸控有什么问题吗？&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Chickking-Website/SomeFile/master/201802/new_wallpaper.png&quot; alt=&quot;Wallpaper&quot;&gt;&lt;br&gt;&lt;em&gt;原图被 QQ 空间压缩的不能看，这张后补。&lt;/em&gt;&lt;br&gt;晚上还发生了一件恐怖的事情，我们忘记了栓门。dzy 在 22:40 左右刚刚打开游戏想玩几分钟，我在床上抱着 Mac 欣赏刚换的壁纸。结果老唐拿着万能房卡闯了进来，后面的事情就不用多说了，还好只是训一顿。&lt;/p&gt;
&lt;h3 id=&quot;Day-5-Day-6&quot;&gt;&lt;a href=&quot;#Day-5-Day-6&quot; class=&quot;headerlink&quot; title=&quot;Day 5 ~ Day 6&quot;&gt;&lt;/a&gt;Day 5 ~ Day 6&lt;/h3&gt;
    
    </summary>
    
    
      <category term="OI" scheme="/tags/OI/"/>
    
  </entry>
  
  <entry>
    <title>栈与队列的基础实现</title>
    <link href="/posts/stack-and-queue-basic/"/>
    <id>/posts/stack-and-queue-basic/</id>
    <published>2018-02-01T16:38:26.000Z</published>
    <updated>2018-08-18T07:53:29.462Z</updated>
    
    <content type="html"><![CDATA[<p>之前学习栈和队列就不是很系统，这会趁着有时间赶紧补一补。</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈 (stack) 是一种“先入后出”的数据结构。栈的基本结构类似洗盘子，你必须把上面的盘子全部移走，才能够取得下面的盘子。栈的图解如下:<br><img src="https://raw.githubusercontent.com/Chickking-Website/SomeFile/master/201802/stack.png" alt="stack picture"><br>可以看出，栈由两部分组成，数据和栈指针。<br>在 C++ 中，我们一般通过数组模拟来实现栈。<br>栈的类型声明如下:  </p><pre><code class="lang-cpp">typedef struct {    int data[MAXN];    int top;} stack;</code></pre><p>栈的一些基本操作包括: 压入、弹出。<br>我们现在就开始编写一些与栈有关的函数。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>栈的初始化很有意思，一般我们在初始化时将栈指针设置为 -1。  </p><pre><code class="lang-cpp">void stack_init(stack *s) {    s-&gt;top = -1;}</code></pre><p>因为接下来我们将数据压入栈的时候，栈指针会先自己加 1，因此将栈指针设置为 -1 可以让第一个元素的指针为 0。<br><span style="color:orange">这里说的“指针”，和 C++ 中常规的指针不同，但其存在的根本意义是一致的。</span></p><h3 id="判断栈空或满"><a href="#判断栈空或满" class="headerlink" title="判断栈空或满"></a>判断栈空或满</h3><p>参照我们初始化栈时的说明，当栈指针等于 -1 时，栈一定是空的。  </p><pre><code class="lang-cpp">bool stack_empty(stack *s) {    return (s-&gt;top == -1) ? true : false;}</code></pre><p>如何判断栈是否满了呢？我们知道，这里栈使用数组模拟，那么如果栈指针等于数组的最大下标，就意味着栈已经满了。</p><pre><code class="lang-cpp">bool stack_full(stack *s) {    return (s-&gt;top == MAXN - 1) ? true : false;}</code></pre><h3 id="栈的压入"><a href="#栈的压入" class="headerlink" title="栈的压入"></a>栈的压入</h3><p>由于存在栈已满的情况，因此我们不能假定操作一定成功，所以函数的返回值应为布尔型。<br>首先应当判断栈是否已满，如果已满肯定是压不进去的。如果没有满，意味着可以压入数据。我们可以直接调用之前实现的函数。<br>压入数据时，首先让栈指针上移一位，然后将栈指针当前指向的栈空间赋值。  </p><pre><code class="lang-cpp">bool stack_push(stack *s, int a) {    if (!stack_full(s)) {        s-&gt;top++;        s-&gt;data[s-&gt;top] = a;        return true;    }     else return false;}</code></pre><h3 id="栈的弹出"><a href="#栈的弹出" class="headerlink" title="栈的弹出"></a>栈的弹出</h3><p>同理，栈可能是空的，如果栈是空的，我们也无法弹出任何数据。<br>栈的弹出操作可以看做是压入操作的逆运算。因此，这里要先取出数据，再将栈指针下移。</p><pre><code class="lang-cpp">bool stack_pop(stack *s, int *a) {    if (!stack_empty(s)) {        *a = s-&gt;data[s-&gt;top];        s-&gt;top--;        return true;    }    else return false;}</code></pre><p>那么为什么这一次，我们要将第二个形参设置为 *a 而不是 a 呢？因为弹出操作需要给变量赋值，而不是取值。因此这里我们使用 * 就是为了让函数操作其作用域之外的但是被传入的变量。</p><h3 id="获取栈顶数据"><a href="#获取栈顶数据" class="headerlink" title="获取栈顶数据"></a>获取栈顶数据</h3><p>这个非常简单，只要当前栈非空，那么栈指针指向的数据一定是栈顶数据。  </p><pre><code class="lang-cpp">bool stack_getTop(stack *s, int *a) {    if (!stack_empty(s)) {        *a = s-&gt;data[s-&gt;top];        return true;    }    else return false;}</code></pre><h3 id="获取栈的有效长度"><a href="#获取栈的有效长度" class="headerlink" title="获取栈的有效长度"></a>获取栈的有效长度</h3><p>这个更是简单至极，甚至无需判断栈是否非空，因为栈的第一个元素指针为 0，所以栈的长度一定是栈指针加上 1。而栈为空时，由于此时栈指针为 -1，$-1 + 1 =0$，完美符合栈空时的长度。(是不是觉得将栈的初始指针设为 -1 很妙啊)  </p><pre><code class="lang-cpp">int stack_length(stack *s) {    return s-&gt;top + 1;}</code></pre><h3 id="栈的遍历"><a href="#栈的遍历" class="headerlink" title="栈的遍历"></a>栈的遍历</h3><p>我们知道，栈是先进后出的数据结构，而且是一个操作受限的线性表。<br>因此，我们要遍历一个栈，只要依次获取当前栈指针指向的数据，再将栈指针下移。<br>我们可以通过栈的弹出操作来简化这一过程:  </p><pre><code class="lang-cpp">void stack_traversal(stack *s) {    int i = 0;    while (!stack_empty(s)) {        stack_pop(s, &amp;i);        printf(&quot;%d &quot;, i);    }    putchar(&#39;\n&#39;);}</code></pre><h3 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h3><p>这个例子展示了输入数据压入栈中，再获取栈长度、栈顶数据，然后对栈遍历的操作。  </p><pre><code class="lang-cpp">#include &lt;cstdio&gt;const int MAXN = 100 + 1;typedef struct {    int data[MAXN];    int top;} stack;void stack_init(stack *s) {    s-&gt;top = -1;}bool stack_empty(stack *s) {    return (s-&gt;top == -1) ? true : false;}bool stack_full(stack *s) {    return (s-&gt;top == MAXN - 1) ? true : false;}bool stack_push(stack *s, int a) {    if (!stack_full(s)) {        s-&gt;top++;        s-&gt;data[s-&gt;top] = a;        return true;    }     else return false;}bool stack_pop(stack *s, int *a /* Because we need to change variable a */) {    if (!stack_empty(s)) {        *a = s-&gt;data[s-&gt;top];        s-&gt;top--;        return true;    }    else return false;}bool stack_getTop(stack *s, int *a) {    if (!stack_empty(s)) {        *a = s-&gt;data[s-&gt;top];        return true;    }    else return false;}int stack_length(stack *s) {    return s-&gt;top + 1;}void stack_traversal(stack *s) {    int i = 0;    while (!stack_empty(s)) {        stack_pop(s, &amp;i);        printf(&quot;%d &quot;, i);    }    putchar(&#39;\n&#39;);}int amount;int main() {    stack a;    stack_init(&amp;a);    scanf(&quot;%d&quot;, &amp;amount);    for (int i = 0, tmpVar = 0; i &lt; amount; i++) {        scanf(&quot;%d&quot;, &amp;tmpVar);        stack_push(&amp;a, tmpVar);    }    int top;    stack_getTop(&amp;a, &amp;top);    printf(&quot;Valid length: %d, Top element: %d\n&quot;, stack_length(&amp;a), top);    printf(&quot;Traversal: \n&quot;);    stack_traversal(&amp;a);    return 0;}</code></pre><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>和栈不同的是，队列 (queue) 是一个“先入先出”的数据结构。你可以把它想象成食堂排队打饭的队列，没有人中途离开 (想离开的都饿死了)，而且不存在插队的情况 (因为插队的都被我们打死了)。<br>这种情况下，在队头的人打上饭离开了，这就叫“出队”。打酱油的人看到前面的人出队了。于是跟进队尾，这就叫“入队”。<br>队列的图解如下:<br><img src="https://raw.githubusercontent.com/Chickking-Website/SomeFile/master/201802/queue.png" alt="queue picture"><br><span style="color: orange">这里我们不讨论循环队列和链表队列等等，我们只讨论最基础的队列。</span><br>在 C++ 中，我们同样通过数组模拟来实现队列。  </p><pre><code class="lang-cpp">typedef struct {    int data[MAXN];    int front;    int rear;} queue;</code></pre><p>队列的基本操作包括: 入队、出队。<br>现在我们就来编写一些和队列有关的函数。  </p><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><p>队列的初始化更加有趣，一般我们把队头指针设置为 0，队尾指针设置为 -1。这当然是有原因的，看下去你就会明白。</p><pre><code class="lang-cpp">void queue_init(queue *q) {    q-&gt;front = 0;    q-&gt;rear = -1;}</code></pre><h3 id="判断队列为空或满"><a href="#判断队列为空或满" class="headerlink" title="判断队列为空或满"></a>判断队列为空或满</h3><p>我们知道，队列是一个只能从前面出队，从后面入队的。也就是说出队操作意味着队头指针的下移，入队操作意味着队尾指针的下移。<br>因此，如果队头指针不断下移，直至移到了比队尾指针还要靠下，那么这个队列必然是空的了。(相等时意味着这是只有一个元素的队列)<br>或者是另一种情况，例如在初始化时，队头指针为 0 而队尾指针为 -1，出现了队尾指针在队头指针上方的情况，这种情况自然也不存在合法的队列了。<br>归纳，我们可以得到，当队头指针在队尾指针下方时，这个队列一定为空。  </p><pre><code class="lang-cpp">bool queue_empty(queue *q) {    if (q-&gt;front &gt; q-&gt;rear) {        return true;    }    else return false;}</code></pre><p>那么我们如何判断队列是否已经满了呢？目前来说，可以暂时看做和栈是一致的。</p><pre><code class="lang-cpp">bool queue_full(queue *q) {    if (q-&gt;rear == MAXN - 1) {        return true;    }    else return false;}</code></pre><p>但事实上，由于出队时队头指针数字的增加，导致虽然看上去队列满了，其实数组中还有空间没有被利用。我们可以通过循环数组等方式来解决这种“假溢出”问题。但这不在本文的讨论范围之内。  </p><h3 id="队列的入-出队操作和获取队头-尾元素"><a href="#队列的入-出队操作和获取队头-尾元素" class="headerlink" title="队列的入/出队操作和获取队头/尾元素"></a>队列的入/出队操作和获取队头/尾元素</h3><p>前面我们已经知道了栈的压入和弹出操作，队列的也类似。只不过入队只能从队尾入队，出队只能从队头出队罢了。</p><pre><code class="lang-cpp">bool queue_in(queue *q, int a) {    if (!queue_full(q)) {        q-&gt;rear++;        q-&gt;data[q-&gt;rear] = a;        return true;    }    else return false;}bool queue_out(queue *q, int *a) {    if (!queue_empty(q)) {        *a=q-&gt;data[q-&gt;front];        q-&gt;front++;        return true;    }    else return false;}</code></pre><p>获取队头队尾元素的方法可以参考栈的说明。</p><pre><code class="lang-cpp">bool queue_getFront(queue *q, int *a) {    if (!queue_empty(q)) {        *a=q-&gt;data[q-&gt;front];        return true;    }    else return false;}bool queue_getRear(queue *q, int *a) {    if (!queue_empty(q)) {        *a=q-&gt;data[q-&gt;rear];        return true;    }     else return false;}</code></pre><h3 id="队列的长度"><a href="#队列的长度" class="headerlink" title="队列的长度"></a>队列的长度</h3><p>如果你面前有一个队列，里面第一个人的编号为 1，最后一个人的编号为 6。你能一眼看出这个队列有 6 个人。<br>显然，$L =n_{rear} - n_{front} + 1$。  </p><pre><code class="lang-cpp">int queue_length(queue *q) {    return q-&gt;rear - q-&gt;front + 1;}</code></pre><h3 id="队列的遍历"><a href="#队列的遍历" class="headerlink" title="队列的遍历"></a>队列的遍历</h3><p>队列的遍历和栈的遍历类似，只是将弹出操作换成了出队操作罢了。   </p><pre><code>void queue_traversal(queue *q) {    int i = 0;    while (!queue_empty(q)) {        queue_out(q, &amp;i);        printf(&quot;%d &quot;, i);    }    putchar(&#39;\n&#39;);}</code></pre><h3 id="示例程序-1"><a href="#示例程序-1" class="headerlink" title="示例程序"></a>示例程序</h3><p>此程序所实现的功能和栈的那个示例类似。</p><pre><code class="lang-cpp">#include &lt;cstdio&gt;const int MAXN = 100 + 1;typedef struct {    int data[MAXN];    int front;    int rear;} queue;void queue_init(queue *q) {    q-&gt;front = 0;    q-&gt;rear = -1;}bool queue_empty(queue *q) {    if (q-&gt;front &gt; q-&gt;rear) {        return true;    }    else return false;}bool queue_full(queue *q) {    if (q-&gt;rear == MAXN - 1) {        return true;    }    else return false;}bool queue_in(queue *q, int a) {    if (!queue_full(q)) {        q-&gt;rear++;        q-&gt;data[q-&gt;rear] = a;        return true;    }    else return false;}bool queue_out(queue *q, int *a) {    if (!queue_empty(q)) {        *a=q-&gt;data[q-&gt;front];        q-&gt;front++;        return true;    }    else return false;} bool queue_getFront(queue *q, int *a) {    if (!queue_empty(q)) {        *a=q-&gt;data[q-&gt;front];        return true;    }    else return false;}bool queue_getRear(queue *q, int *a) {    if (!queue_empty(q)) {        *a=q-&gt;data[q-&gt;rear];        return true;    }     else return false;}int queue_length(queue *q) {    return q-&gt;rear - q-&gt;front + 1;}void queue_traversal(queue *q) {    int i = 0;    while (!queue_empty(q)) {        queue_out(q, &amp;i);        printf(&quot;%d &quot;, i);    }    putchar(&#39;\n&#39;);}int amount;int main() {    queue a;    queue_init(&amp;a);    scanf(&quot;%d&quot;, &amp;amount);    for (int i = 0, tmpVar = 0; i &lt; amount; i++) {        scanf(&quot;%d&quot;, &amp;tmpVar);        queue_in(&amp;a, tmpVar);    }    int front, rear;    queue_getFront(&amp;a, &amp;front);    queue_getRear(&amp;a, &amp;rear);    printf(&quot;Valid length: %d, Front element: %d, Rear element: %d\n&quot;, queue_length(&amp;a), front, rear);    printf(&quot;Traversal: \n&quot;);    queue_traversal(&amp;a);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前学习栈和队列就不是很系统，这会趁着有时间赶紧补一补。&lt;/p&gt;
&lt;h2 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; class=&quot;headerlink&quot; title=&quot;栈&quot;&gt;&lt;/a&gt;栈&lt;/h2&gt;&lt;p&gt;栈 (stack) 是一种“先入后出”的数据结构。栈的基本结构类似洗盘子，你必须把上面的盘子全部移走，才能够取得下面的盘子。栈的图解如下:&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Chickking-Website/SomeFile/master/201802/stack.png&quot; alt=&quot;stack picture&quot;&gt;&lt;br&gt;可以看出，栈由两部分组成，数据和栈指针。&lt;br&gt;在 C++ 中，我们一般通过数组模拟来实现栈。&lt;br&gt;栈的类型声明如下:  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;typedef struct {
    int data[MAXN];
    int top;
} stack;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;栈的一些基本操作包括: 压入、弹出。&lt;br&gt;我们现在就开始编写一些与栈有关的函数。&lt;/p&gt;
&lt;h3 id=&quot;初始化&quot;&gt;&lt;a href=&quot;#初始化&quot; class=&quot;headerlink&quot; title=&quot;初始化&quot;&gt;&lt;/a&gt;初始化&lt;/h3&gt;&lt;p&gt;栈的初始化很有意思，一般我们在初始化时将栈指针设置为 -1。  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;void stack_init(stack *s) {
    s-&amp;gt;top = -1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为接下来我们将数据压入栈的时候，栈指针会先自己加 1，因此将栈指针设置为 -1 可以让第一个元素的指针为 0。&lt;br&gt;&lt;span style=&quot;color:orange&quot;&gt;这里说的“指针”，和 C++ 中常规的指针不同，但其存在的根本意义是一致的。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;判断栈空或满&quot;&gt;&lt;a href=&quot;#判断栈空或满&quot; class=&quot;headerlink&quot; title=&quot;判断栈空或满&quot;&gt;&lt;/a&gt;判断栈空或满&lt;/h3&gt;
    
    </summary>
    
    
      <category term="OI" scheme="/tags/OI/"/>
    
      <category term="C++" scheme="/tags/C/"/>
    
      <category term="数据结构" scheme="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="线性表" scheme="/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>打造自己的随身 Ubuntu</title>
    <link href="/posts/make-your-own-ubuntu-to-go/"/>
    <id>/posts/make-your-own-ubuntu-to-go/</id>
    <published>2018-01-13T11:55:20.000Z</published>
    <updated>2018-08-18T07:53:29.460Z</updated>
    
    <content type="html"><![CDATA[<p>如今真的是 Windows 满天飞啊，虽然说好了不黑 Windows 了，但是那个系统实在让我感到难受。（cmd.exe 的锅占一半）</p><p>虽然大部分时间都可以用 Mac，但是还是有可能会用到外面的电脑。如果不想用 Windows 怎么办？随身携带一个操作系统是非常好的解决方案。</p><p>显然，我们不能携带 macOS。因为 Mac 还没有普及到满地都是，而 Hackintosh 需要针对每台机器进行不同的配置，完全不适合携带。那么我们只能选择 Linux 阵营。在 Linux 中，权衡各方面利弊，我选择了 Ubuntu 17.10 artful.</p><p>先晒晒截图。<br><img src="https://github.com/Chickking-Website/SomeFile/raw/master/201801/ubuntu/2018-01-13%2019-45-28%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="Dash"><br><img src="https://github.com/Chickking-Website/SomeFile/raw/master/201801/ubuntu/2018-01-13%2019-46-18%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="Chrome"><br><img src="https://github.com/Chickking-Website/SomeFile/blob/master/201801/ubuntu/2018-01-13%2019-53-27%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png?raw=true" alt="Integration"></p><p>1月14日更新，Ubuntu 已经通过 Docky 使用 Dock。<br><img src="https://github.com/Chickking-Website/SomeFile/blob/master/201801/ubuntu/2018-01-14%2012-59-55%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png?raw=true" alt="Dock"></p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>建议有一个可用的 macOS 环境，以便安装 Clover EFI Tools。<br>一个 USB 磁盘，建议 USB 3.0 + 64GB。<br>Ubuntu 17.10 artful.  </p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>我们首先需要将 Ubuntu 安装到 U 盘中。安装过程建议使用虚拟机，并采取 EFI + GPT 的方式。<br>安装完成后，你会发现 Ubuntu 可能不能正常启动，此时需要先安装 grub。<br>grub 的安装非常简单，这里不再赘述。网上这样的教程一大把一大把的。<br>重点是，如果遇上不支持 EFI 的电脑怎么办？<br>折腾过黑苹果的同学可能知道，Clover 有一个安装方式是 EFI Tools。其中，EFI Tools 提供了安装模拟 UEFI 环境的功能。<br>EFI Tools 也比较好找，例如:链接: <a href="https://pan.baidu.com/s/1dFTprdJ" target="_blank" rel="noopener">https://pan.baidu.com/s/1dFTprdJ</a> 密码: 76gm。版本虽然有些老，但是我们的重点是里面模拟 UEFI 的 boot0ss。<br>在 macOS 启动 EFI Tools 并选择 “G、挂载 EFI 分区到桌面不格式化(Fat32)”，然后“H、(一)安装 Clover EFI 开机引导文件(Fat32)”，注意要挂载的是 U 盘的 EFI 分区。<br>将启动文件写入后，在终端中执行以下命令。</p><pre><code class="lang-bash"># 这里假设您的 EFI 分区在 /Volumes/EFI 挂载dir=&quot;/Volumes/EFI&quot;mkdir $dir/EFI/BOOTrm -rf $dir/EFI/CLOVER/*cp $dir/EFI/ubuntu/grubx64.efi $dir/EFI/BOOT/BOOTX64.EFIcp $dir/EFI/ubuntu/grubx64.efi $dir/EFI/CLOVER/CLOVERX64.EFI</code></pre><p>这样，U盘就能够在不支持 EFI 的电脑上启动了。<br>我们可以在 Ubuntu 的 <code>/etc/grub.d/40_custom</code> 中加入一些自定义代码，来扩充 grub 的菜单项。我的如下：</p><pre><code class="lang-bash">#!/bin/shexec tail -n +3 $0menuentry &#39;退出 Grub&#39; {        exit}menuentry &#39;ACPI 关闭计算机&#39; {        halt}menuentry &#39;重新启动计算机&#39; {        reboot}# This file provides an easy way to add custom menu entries.  Simply type the# menu entries you want to add after this comment.  Be careful not to change# the &#39;exec tail&#39; line above.</code></pre><h2 id="桌面美化"><a href="#桌面美化" class="headerlink" title="桌面美化"></a>桌面美化</h2><p>从第三张截图可以看到，尽管 Unity 在 Ubuntu 17.10 artful. 中已经被抛弃，我还是更愿意使用它。因为 Unity 对全局菜单支持的很好。这是我非常喜欢的 Mac 的功能之一，在 Ubuntu 上自然不可或缺。<br>主题使用 OSX-Arc-Darker，图标使用 Ultra-Flat。<br>字体是我这个 Ubuntu 的特别之处，使用苹方、San Francisco 和 SF Mono，而不是 Ubuntu 默认字体。<br><strong><span style="color: red">注意： 由于苹方、San Francisco、SF Mono 字体的版权归 Apple Inc. 所有，我不确定是否有潜在的法律风险，故不提供下载。请自行去 macOS 中提取使用。</span></strong><br>SF Mono 路径： <code>/Applications/Xcode.app/Contents/SharedFrameworks/DVTKit.framework/Versions/A/Resources/Fonts</code>。<br>San Francisco + 苹方都在 <code>/Library/Fonts/</code> 下。<br>通过 <code>unity-tweak-tool</code>  加载使用。该工具还可以调节很多东西。 </p><h2 id="常用软件"><a href="#常用软件" class="headerlink" title="常用软件"></a>常用软件</h2><p>我在 macOS 上日常会使用的软件一般包括 Safari、oh-my-zsh、Sublime Text、Moeditor、搜狗拼音、QQ、微信、网易云音乐等。<br><em>1月14日更新，现在文档软件使用的是 WPS Office。</em><br>浏览器方面，Safari 肯定不行了。Ubuntu 自带了 Firefox 浏览器，如果你喜欢当然很好，但是 Ubuntu 自带的 Firefox 实在不怎么样。因此我们要替换浏览器。<br>我建议直接安装 Chrome。<br>oh-my-zsh 也是非常有用的 zsh 扩展，详情可以到  <a href="https://ohmyz.sh/" target="_blank" rel="noopener">https://ohmyz.sh/</a> 查看。<br>Sublime Text、Moeditor、搜狗拼音也可以直接下载安装。<br>QQ 这个东西不太好办，我最终选择安装一个 VirtualBox 虚拟机，系统采用 《Deepin.XP.SP3.Lite.完美精简版.iso》占据空间很小，分配 8GB 的空间足矣。<br>微信的话，有一个第三方封装的项目——<a href="https://github.com/geeeeeeeeek/electronic-wechat" target="_blank" rel="noopener">electronic-wechat</a>。我替它做了一个图标和 Desktop 文件。图标在下面提供，直接保存即可。<br><img src="https://github.com/Chickking-Website/SomeFile/blob/master/201801/ubuntu/wechat_logo/icon.png?raw=true" alt="WeChat icon"><br>Desktop 文件请将如下代码保存到 <code>/usr/share/applications/wechat.desktop</code>。其中请将 <code>#YOUR DOWNLOADED DIR#</code> 替换成你保存这个项目 release 文件夹的路径，<code>#ICON PATH#</code> 替换成你下载的图标的路径。</p><pre><code class="lang-plain">[Desktop Entry]Name=WeChatGenericName=WeChatComment=WeChat built with electronExec=#YOUR DOWNLOADED DIR#/electronic-wechatIcon=#ICON PATH#Terminal=falseType=ApplicationCategories=Network;StartupNotify=true</code></pre><p>网易云音乐在 Ubuntu 17.10 artful 上可能无法使用，是因为依赖包的问题。<a href="https://www.jianshu.com/p/6f0747db7018" target="_blank" rel="noopener">这篇文章</a> 提供了解决方案。<br>WPS Office 是比较符合我们使用习惯的。有一个问题是它在高分屏下的界面有点问题，不过功能是正常的。在安装时，可能会遇到依赖问题。<br>要解决 WPS Office 的依赖问题，首先要将它的依赖包装齐：</p><pre><code class="lang-bash">sudo apt-get install libc6 libfreetype6 libcups2 libglib2.0-0 libpng12-0 libglu1-mesa libsm6 libxrender1 libfontconfig1 libxext6 libxcb1</code></pre><p>你可能会发现 <code>libpng12-0</code> 不能正常安装。这样的话我们就只能去 Ubuntu 16.04 的源安装：</p><pre><code>wget http://kr.archive.ubuntu.com/ubuntu/pool/main/libp/libpng/libpng12-0_1.2.54-1ubuntu1_amd64.debsudo dpkg -i libpng12-0_1.2.54-1ubuntu1_amd64.deb</code></pre><p>然后去 <a href="http://wps-community.org/download.html" target="_blank" rel="noopener">WPS Community</a> 下载最新的 <code>wps-office_10.1.0.5707~a21_amd64.deb</code> 安装即可。<br>另外 ShadowsocksR 在 Ubuntu 上的配置也比较难找，我在下一篇博文中详细叙述了配置方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如今真的是 Windows 满天飞啊，虽然说好了不黑 Windows 了，但是那个系统实在让我感到难受。（cmd.exe 的锅占一半）&lt;/p&gt;
&lt;p&gt;虽然大部分时间都可以用 Mac，但是还是有可能会用到外面的电脑。如果不想用 Windows 怎么办？随身携带一个操作系统是非常好的解决方案。&lt;/p&gt;
&lt;p&gt;显然，我们不能携带 macOS。因为 Mac 还没有普及到满地都是，而 Hackintosh 需要针对每台机器进行不同的配置，完全不适合携带。那么我们只能选择 Linux 阵营。在 Linux 中，权衡各方面利弊，我选择了 Ubuntu 17.10 artful.&lt;/p&gt;
&lt;p&gt;先晒晒截图。&lt;br&gt;&lt;img src=&quot;https://github.com/Chickking-Website/SomeFile/raw/master/201801/ubuntu/2018-01-13%2019-45-28%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png&quot; alt=&quot;Dash&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://github.com/Chickking-Website/SomeFile/raw/master/201801/ubuntu/2018-01-13%2019-46-18%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png&quot; alt=&quot;Chrome&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://github.com/Chickking-Website/SomeFile/blob/master/201801/ubuntu/2018-01-13%2019-53-27%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png?raw=true&quot; alt=&quot;Integration&quot;&gt;&lt;/p&gt;
&lt;p&gt;1月14日更新，Ubuntu 已经通过 Docky 使用 Dock。&lt;br&gt;&lt;img src=&quot;https://github.com/Chickking-Website/SomeFile/blob/master/201801/ubuntu/2018-01-14%2012-59-55%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png?raw=true&quot; alt=&quot;Dock&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h2&gt;&lt;p&gt;建议有一个可用的 macOS 环境，以便安装 Clover EFI Tools。&lt;br&gt;一个 USB 磁盘，建议 USB 3.0 + 64GB。&lt;br&gt;Ubuntu 17.10 artful.  &lt;/p&gt;
&lt;h2 id=&quot;启动&quot;&gt;&lt;a href=&quot;#启动&quot; class=&quot;headerlink&quot; title=&quot;启动&quot;&gt;&lt;/a&gt;启动&lt;/h2&gt;&lt;p&gt;我们首先需要将 Ubuntu 安装到 U 盘中。安装过程建议使用虚拟机，并采取 EFI + GPT 的方式。&lt;br&gt;安装完成后，你会发现 Ubuntu 可能不能正常启动，此时需要先安装 grub。&lt;br&gt;grub 的安装非常简单，这里不再赘述。网上这样的教程一大把一大把的。&lt;br&gt;重点是，如果遇上不支持 EFI 的电脑怎么办？&lt;br&gt;折腾过黑苹果的同学可能知道，Clover 有一个安装方式是 EFI Tools。其中，EFI Tools 提供了安装模拟 UEFI 环境的功能。&lt;br&gt;EFI Tools 也比较好找，例如:链接: &lt;a href=&quot;https://pan.baidu.com/s/1dFTprdJ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://pan.baidu.com/s/1dFTprdJ&lt;/a&gt; 密码: 76gm。版本虽然有些老，但是我们的重点是里面模拟 UEFI 的 boot0ss。&lt;br&gt;在 macOS 启动 EFI Tools 并选择 “G、挂载 EFI 分区到桌面不格式化(Fat32)”，然后“H、(一)安装 Clover EFI 开机引导文件(Fat32)”，注意要挂载的是 U 盘的 EFI 分区。&lt;br&gt;将启动文件写入后，在终端中执行以下命令。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;# 这里假设您的 EFI 分区在 /Volumes/EFI 挂载
dir=&amp;quot;/Volumes/EFI&amp;quot;
mkdir $dir/EFI/BOOT
rm -rf $dir/EFI/CLOVER/*
cp $dir/EFI/ubuntu/grubx64.efi $dir/EFI/BOOT/BOOTX64.EFI
cp $dir/EFI/ubuntu/grubx64.efi $dir/EFI/CLOVER/CLOVERX64.EFI
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="/tags/Linux/"/>
    
      <category term="Ubuntu" scheme="/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>「NOIP2015」神奇的幻方</title>
    <link href="/posts/noip2015_magic_square/"/>
    <id>/posts/noip2015_magic_square/</id>
    <published>2017-12-30T00:31:20.000Z</published>
    <updated>2018-08-18T07:53:29.461Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>幻方是一种很神奇的 $N \times N$ 矩阵：它由数字 $1,2,3,\cdots \cdots ,N \times N$ 构成，且每行、每列及两条对角线上的数字之和都相同。</p><p>当 $N$ 为奇数时，我们可以通过下方法构建一个幻方：</p><p>首先将 $1$ 写在第一行的中间。</p><p>之后，按如下方式从小到大依次填写每个数 $K (K=2,3,\cdots,N \times N)$ ：</p><p>1.若 $(K-1)$ 在第一行但不在最后一列，则将 $K$ 填在最后一行， $(K-1)$ 所在列的右一列；</p><p>2.若 $(K-1)$ 在最后一列但不在第一行，则将 $K$ 填在第一列， $(K-1)$ 所在行的上一行；</p><p>3.若 $(K-1)$ 在第一行最后一列，则将 $K$ 填在 $(K-1)$ 的正下方；</p><p>4.若 $(K-1)$ 既不在第一行，也不在最后一列，如果 $(K-1)$ 的右上方还未填数，则将 $K$ 填在 $(K-1)$ 的右上方，否则将 $K$ 填在 $(K-1)$ 的正下方。</p><p>现给定 $N$ ，请按上述方法构造 $N \times N$ 的幻方。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入文件只有一行，包含一个正整数 $N$ ，即幻方的大小。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出文件包含 $N$ 行 ，每行 $N$ 个整数，即按上述方法构造出的 $N \times N$ 的幻方，相邻两个整数之间用单空格隔开。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><pre><code class="lang-plain">3</code></pre><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><pre><code class="lang-plain">8 1 63 5 74 9 2</code></pre><h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示:"></a>数据范围与提示:</h2><p>对于全部的数据， $1 \leq N \leq 39$ 且 $N$ 为奇数。</p><p>时间限制：1 s</p><p>空间限制：128 MiB</p><h2 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h2><pre><code class="lang-c++">#include &lt;iostream&gt;using std::cin;using std::cout;using std::endl;const int MAX_ROW = 39 + 1, MAX_COLUMN = 39 + 1;int sq[MAX_COLUMN][MAX_ROW], n, column, row;int main() {    cin &gt;&gt; n;    row = 1;    column = (n / 2) + 1;    sq[column][row] = 1;    for (int i = 2; i &lt;= n * n; i++) {        if (row == 1 &amp;&amp; column != n) {            row = n;            column++;        }        else if (column == n &amp;&amp; row != 1) {            column = 1;            row--;        }        else if (row == 1 &amp;&amp; column == n) {            row++;        }        else {            if (sq[column + 1][row - 1] == 0) {                row--;                column++;            }            else {                row++;            }        }        sq[column][row] = i;    }    for (int i = 1; i &lt;= n; i++) {        for (int j = 1; j &lt;= n; j++) {            cout &lt;&lt; sq[j][i] &lt;&lt; &quot; &quot;;        }        cout &lt;&lt; endl;    }} /*#2. 「NOIP2015」神奇的幻方https://ly.men.ci/problem/2*/</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;幻方是一种很神奇的 $N \times N$ 矩阵：它由数字 $1,2,3,\cdots \cdots ,N \times N$ 构成，且每行、每列及两条对角线上的数字之和都相同。&lt;/p&gt;
&lt;p&gt;当 $N$ 为奇数时，我们可以通过下方法构建一个幻方：&lt;/p&gt;
&lt;p&gt;首先将 $1$ 写在第一行的中间。&lt;/p&gt;
&lt;p&gt;之后，按如下方式从小到大依次填写每个数 $K (K=2,3,\cdots,N \times N)$ ：&lt;/p&gt;
&lt;p&gt;1.若 $(K-1)$ 在第一行但不在最后一列，则将 $K$ 填在最后一行， $(K-1)$ 所在列的右一列；&lt;/p&gt;
&lt;p&gt;2.若 $(K-1)$ 在最后一列但不在第一行，则将 $K$ 填在第一列， $(K-1)$ 所在行的上一行；&lt;/p&gt;
&lt;p&gt;3.若 $(K-1)$ 在第一行最后一列，则将 $K$ 填在 $(K-1)$ 的正下方；&lt;/p&gt;
&lt;p&gt;4.若 $(K-1)$ 既不在第一行，也不在最后一列，如果 $(K-1)$ 的右上方还未填数，则将 $K$ 填在 $(K-1)$ 的右上方，否则将 $K$ 填在 $(K-1)$ 的正下方。&lt;/p&gt;
&lt;p&gt;现给定 $N$ ，请按上述方法构造 $N \times N$ 的幻方。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI" scheme="/tags/OI/"/>
    
      <category term="C++" scheme="/tags/C/"/>
    
      <category term="NOIP" scheme="/tags/NOIP/"/>
    
  </entry>
  
  <entry>
    <title>数组初始化长度问题</title>
    <link href="/posts/variable-as-array-s-initial-length/"/>
    <id>/posts/variable-as-array-s-initial-length/</id>
    <published>2017-12-21T05:33:20.000Z</published>
    <updated>2018-08-18T07:53:29.463Z</updated>
    
    <content type="html"><![CDATA[<p>最近正在 studying OI，今天中午闲的没事写了个冒泡排序。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入整数进行升序排序。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>共两行，第一行输入数字 $n$，第二行输入 $n$ 个数字。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出排序完成的数据。</p><h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><pre><code>63 4 8 5 7 9</code></pre><h4 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h4><pre><code>3 4 5 7 8 9</code></pre><h3 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h3><p>对于 $100\%$ 的数据，都属于区间 $(0,1000)$。</p><h3 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码:"></a>AC 代码:</h3><pre><code class="lang-C++">#include &lt;iostream&gt;using std::cin;using std::cout;using std::endl;int main() {    int N = 0;    cin &gt;&gt; N;    int a[N];    for (int i = 0; i &lt; N; i++) cin &gt;&gt; a[i];    int tmpVar = 0;    for (int i = 0; i &lt; N; i++)        for (int j = N - 1; j &gt;= 0; j--) {            if (a[j - 1] &gt; a[j]) {                tmpVar = a[j];                a[j] = a[j - 1];                a[j - 1] = tmpVar;            }    }    for (int i = 0; i &lt; N; i++) {        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;    }    cout &lt;&lt; endl;    return 0;}</code></pre><h2 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h2><p>很多书本上看到，数组的长度不能使用变量定义。但是目前来看，用变量定义数组长度的代码在 gcc、clang 下都可以直接编译通过，且没有 Warning。不知道这种做法在考场上会不会有风险。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近正在 studying OI，今天中午闲的没事写了个冒泡排序。&lt;/p&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;输入整数进行升序排序。&lt;/p&gt;
&lt;h3 id=&quot;输入格式&quot;&gt;&lt;a href=&quot;#输入格式&quot; class=&quot;headerlink&quot; title=&quot;输入格式&quot;&gt;&lt;/a&gt;输入格式&lt;/h3&gt;&lt;p&gt;共两行，第一行输入数字 $n$，第二行输入 $n$ 个数字。&lt;/p&gt;
&lt;h3 id=&quot;输出格式&quot;&gt;&lt;a href=&quot;#输出格式&quot; class=&quot;headerlink&quot; title=&quot;输出格式&quot;&gt;&lt;/a&gt;输出格式&lt;/h3&gt;&lt;p&gt;输出排序完成的数据。&lt;/p&gt;
&lt;h3 id=&quot;样例&quot;&gt;&lt;a href=&quot;#样例&quot; class=&quot;headerlink&quot; title=&quot;样例&quot;&gt;&lt;/a&gt;样例&lt;/h3&gt;&lt;h4 id=&quot;输入样例&quot;&gt;&lt;a href=&quot;#输入样例&quot; class=&quot;headerlink&quot; title=&quot;输入样例&quot;&gt;&lt;/a&gt;输入样例&lt;/h4&gt;
    
    </summary>
    
    
      <category term="OI" scheme="/tags/OI/"/>
    
      <category term="C++" scheme="/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>ASUS Pro451L 的 High Sierra 安装报告——99% 完美</title>
    <link href="/posts/asus_pro451l_high_sierra_hackintosh/"/>
    <id>/posts/asus_pro451l_high_sierra_hackintosh/</id>
    <published>2017-11-29T15:49:20.000Z</published>
    <updated>2018-06-05T16:31:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>记得当时 OS X El Capitan 的时候，发过一篇<a href="https://imvictor.tech/posts/98-percent-perfection-of-ASUS-Pro451L/" target="_blank" rel="external">《【Hack】ASUS Pro451L 黑苹果 98% 完美》</a>。现在已经是 macOS High Sierra 了。老妈的这个本子也被我更新到了最新的系统。期间踩了不少坑，现在就把折腾的经验和全套驱动加上 EFI 文件夹 (序列号等已清除，请自行加入) 发上来。<br>配置清单:</p><ul><li>[x] CPU: Intel Core i5-4200U 2.39GHz</li><li>[x] 内存: 8GB DDR3 1600MHz (后期添加 4GB)</li><li>[x] 硬盘: WDC SSD 128GB (后期更换，Trim 已开启)</li><li>[x] 显卡: Intel HD Graphics 4400 1536MB + NVIDIA GeForce 820M 2GB (Optimus 技术独显无法使用，已屏蔽)</li><li>[x] 声卡: Conexant SmartAudio CX20751/2 (AppleALC 驱动，麦克风不可用)</li><li>[x] LAN 网卡: Realtek RTL8168</li><li>[x] Wi-Fi/Bluetooth: Broadcom BCM94352HMB (更换)  </li><li>[x] 触控板: ELAN Touchpad (10.13 触控板手势无法自定义，需配合快捷键修改使用)</li></ul><p>完美、不完美清单:</p><ul><li>[x] 电池电量显示</li><li>[x] Continuity</li><li>[x] 亮度调节小太阳</li><li>[x] SIP 完全开启~</li><li>[x] App Store 系统更新</li><li>[x] VGA 输出</li><li>[x] iMessage、FaceTime (虽然能用但是怕被 Apple 查，不敢用)</li><li>[ ] CX20751/2 声卡麦克风</li><li>[ ] 触摸板手势还有一点问题</li><li>[ ] 黑苹果哪有完美的 </li></ul><p>其中我说到了 SIP 完全开启，这意味着系统的 kext 签名完全正常，也就是说，这和一台真正的 MacBook Pro 在系统完整性上是一致的。  </p><p>上一张运行截图:<br><img src="https://raw.githubusercontent.com/Chickking-Website/SomeFile/master/201711/Hackintosh-Working-10.13.png" alt="macOS High Sierra"></p><h2 id="ACPI"><a href="#ACPI" class="headerlink" title="ACPI"></a>ACPI</h2><p>在这一段，我尽量写出 Patch 的过程，方便机型相近但不同的朋友参考。<br>首先，对于 NVIDIA Optimus 技术的双显卡机型，10.13 由于 Metal 2 技术的加入，对于 Optimus 双显卡的机型必须将独显屏蔽。这个是当时远景的一位热心人士帮我制作的。我后来看了一下，代码是在 SSDT-11 里面，可能应用了 RehabMan 源里的 Patch。<br>10.13 还需要加入 _DSM 模块，这个大家可以下载我的 ACPI 文件来看。<br>电池的我是使用了 RehabMan 源 (本帖若无特殊说明打的补丁均来自 RehabMan 源)中的 <code>[bat] ASUS G75VW</code> Patch 到 DSDT 中。<br>亮度调节在 High Sierra 中使用 DSDT。打的补丁是 <code>[igpu] Brightness fix (Haswell/Broadwell)</code>。还有 <code>http://github.com/RehabMan/HP-ProBook-4x30s-DSDT-Patch/raw/master</code> 源中的 <code>[7.1] Native brightness fix</code>。由于这个源不常见，现将 Patch 文件<a href="https://github.com/RehabMan/HP-ProBook-4x30s-DSDT-Patch/raw/2034caef887b1668a7c8fa653511cf60c164d6c6/patches/13_Brightness.txt" target="_blank" rel="external">附上</a>。<br>其他补丁还有 <code>[sys] OS Check Fix (Windows 8)</code>、<code>[sys] Shutdown Fix v2</code>、<code>[sys] Add IMEI</code> 等。<br>值得注意的是我并不推荐大家使用原版 MaciASL，内置的 iasl 版本不能胜任反编译的工作。因此，我编译了最新的 iasl 并制作了一个修改版的 MaciASL，<a href="https://raw.githubusercontent.com/Chickking-Website/SomeFile/master/201711/MaciASL.zip" target="_blank" rel="external">点此下载</a>。  </p><h2 id="引导器配置"><a href="#引导器配置" class="headerlink" title="引导器配置"></a>引导器配置</h2><p>EFI 及相关 kext 见 GitHub 项目。SIP 完全开启，需要的请自行关闭。<br>项目地址: <a href="https://github.com/Chickking/ASUS-Pro451L-Hackintosh-EFI/" target="_blank" rel="external">https://github.com/Chickking/ASUS-Pro451L-Hackintosh-EFI/</a></p><p>请自行取用。SMBIOS 等敏感信息已经去除。DSDT 等已经内置。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记得当时 OS X El Capitan 的时候，发过一篇&lt;a href=&quot;https://imvictor.tech/posts/98-percent-perfection-of-ASUS-Pro451L/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《【Hack】ASUS Pro451L 黑苹果 98% 完美》&lt;/a&gt;。现在已经是 macOS High Sierra 了。老妈的这个本子也被我更新到了最新的系统。期间踩了不少坑，现在就把折腾的经验和全套驱动加上 EFI 文件夹 (序列号等已清除，请自行加入) 发上来。&lt;br&gt;配置清单:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[x] CPU: Intel Core i5-4200U 2.39GHz&lt;/li&gt;
&lt;li&gt;[x] 内存: 8GB DDR3 1600MHz (后期添加 4GB)&lt;/li&gt;
&lt;li&gt;[x] 硬盘: WDC SSD 128GB (后期更换，Trim 已开启)&lt;/li&gt;
&lt;li&gt;[x] 显卡: Intel HD Graphics 4400 1536MB + NVIDIA GeForce 820M 2GB (Optimus 技术独显无法使用，已屏蔽)&lt;/li&gt;
&lt;li&gt;[x] 声卡: Conexant SmartAudio CX20751/2 (AppleALC 驱动，麦克风不可用)&lt;/li&gt;
&lt;li&gt;[x] LAN 网卡: Realtek RTL8168&lt;/li&gt;
&lt;li&gt;[x] Wi-Fi/Bluetooth: Broadcom BCM94352HMB (更换)  &lt;/li&gt;
&lt;li&gt;[x] 触控板: ELAN Touchpad (10.13 触控板手势无法自定义，需配合快捷键修改使用)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;完美、不完美清单:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[x] 电池电量显示&lt;/li&gt;
&lt;li&gt;[x] Continuity&lt;/li&gt;
&lt;li&gt;[x] 亮度调节小太阳&lt;/li&gt;
&lt;li&gt;[x] SIP 完全开启~&lt;/li&gt;
&lt;li&gt;[x] App Store 系统更新&lt;/li&gt;
&lt;li&gt;[x] VGA 输出&lt;/li&gt;
&lt;li&gt;[x] iMessage、FaceTime (虽然能用但是怕被 Apple 查，不敢用)&lt;/li&gt;
&lt;li&gt;[ ] CX20751/2 声卡麦克风&lt;/li&gt;
&lt;li&gt;[ ] 触摸板手势还有一点问题&lt;/li&gt;
&lt;li&gt;[ ] 黑苹果哪有完美的 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中我说到了 SIP 完全开启，这意味着系统的 kext 签名完全正常，也就是说，这和一台真正的 MacBook Pro 在系统完整性上是一致的。  &lt;/p&gt;
&lt;p&gt;上一张运行截图:&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Chickking-Website/SomeFile/master/201711/Hackintosh-Working-10.13.png&quot; alt=&quot;macOS High Sierra&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;ACPI&quot;&gt;&lt;a href=&quot;#ACPI&quot; class=&quot;headerlink&quot; title=&quot;ACPI&quot;&gt;&lt;/a&gt;ACPI&lt;/h2&gt;&lt;p&gt;在这一段，我尽量写出 Patch 的过程，方便机型相近但不同的朋友参考。&lt;br&gt;首先，对于 NVIDIA Optimus 技术的双显卡机型，10.13 由于 Metal 2 技术的加入，对于 Optimus 双显卡的机型必须将独显屏蔽。这个是当时远景的一位热心人士帮我制作的。我后来看了一下，代码是在 SSDT-11 里面，可能应用了 RehabMan 源里的 Patch。&lt;br&gt;10.13 还需要加入 _DSM 模块，这个大家可以下载我的 ACPI 文件来看。&lt;br&gt;电池的我是使用了 RehabMan 源 (本帖若无特殊说明打的补丁均来自 RehabMan 源)中的 &lt;code&gt;[bat] ASUS G75VW&lt;/code&gt; Patch 到 DSDT 中。&lt;br&gt;亮度调节在 High Sierra 中使用 DSDT。打的补丁是 &lt;code&gt;[igpu] Brightness fix (Haswell/Broadwell)&lt;/code&gt;。还有 &lt;code&gt;http://github.com/RehabMan/HP-ProBook-4x30s-DSDT-Patch/raw/master&lt;/code&gt; 源中的 &lt;code&gt;[7.1] Native brightness fix&lt;/code&gt;。由于这个源不常见，现将 Patch 文件&lt;a href=&quot;https://github.com/RehabMan/HP-ProBook-4x30s-DSDT-Patch/raw/2034caef887b1668a7c8fa653511cf60c164d6c6/patches/13_Brightness.txt&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;附上&lt;/a&gt;。&lt;br&gt;其他补丁还有 &lt;code&gt;[sys] OS Check Fix (Windows 8)&lt;/code&gt;、&lt;code&gt;[sys] Shutdown Fix v2&lt;/code&gt;、&lt;code&gt;[sys] Add IMEI&lt;/code&gt; 等。&lt;br&gt;值得注意的是我并不推荐大家使用原版 MaciASL，内置的 iasl 版本不能胜任反编译的工作。因此，我编译了最新的 iasl 并制作了一个修改版的 MaciASL，&lt;a href=&quot;https://raw.githubusercontent.com/Chickking-Website/SomeFile/master/201711/MaciASL.zip&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;点此下载&lt;/a&gt;。  &lt;/p&gt;
&lt;h2 id=&quot;引导器配置&quot;&gt;&lt;a href=&quot;#引导器配置&quot; class=&quot;headerlink&quot; title=&quot;引导器配置&quot;&gt;&lt;/a&gt;引导器配置&lt;/h2&gt;&lt;p&gt;EFI 及相关 kext 见 GitHub 项目。SIP 完全开启，需要的请自行关闭。&lt;br&gt;项目地址: &lt;a href=&quot;https://github.com/Chickking/ASUS-Pro451L-Hackintosh-EFI/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/Chickking/ASUS-Pro451L-Hackintosh-EFI/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="苹果" scheme="/tags/%E8%8B%B9%E6%9E%9C/"/>
    
      <category term="Hack" scheme="/tags/Hack/"/>
    
      <category term="黑苹果" scheme="/tags/%E9%BB%91%E8%8B%B9%E6%9E%9C/"/>
    
      <category term="macOS" scheme="/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 博客程序初步完善</title>
    <link href="/posts/standardly-perfect-hexo-blog/"/>
    <id>/posts/standardly-perfect-hexo-blog/</id>
    <published>2017-11-04T08:09:20.000Z</published>
    <updated>2018-08-18T07:53:29.462Z</updated>
    
    <content type="html"><![CDATA[<p>切换到 Hexo 之后，首要的任务就是把之前的一些轮子再造一遍。  </p><h2 id="1-版权声明和原文链接"><a href="#1-版权声明和原文链接" class="headerlink" title="1. 版权声明和原文链接"></a>1. 版权声明和原文链接</h2><p>在旧的博客中，我曾经加入过这样的功能:<br><img src="https://raw.githubusercontent.com/Chickking-Website/SomeFile/master/201711/sourcemark.png" alt="版权声明和原文链接"><br>在 emlog 中，这些非常容易做。而在 Hexo 中，这也不是难事。<br>我使用的是 yilia 主题，在主题的 <code>layout/_partial/article.ejs</code> 中，在 <code>&lt;% post.content %&gt;</code> 之后加入以下代码:</p><pre><code>&lt;% if (config.copyrights &amp;&amp; page.layout == &quot;post&quot;) { %&gt;    &lt;hr&gt;    &lt;p&gt;本文著作权归作者所有，允许非商业性转载使用，但请在转载后文末附上原文链接。&lt;/p&gt;    &lt;p&gt;原文链接: &lt;a href=&quot;https://&lt;%= config.domain %&gt;&lt;%= post.permalink %&gt;&quot;&gt;https://&lt;%= config.domain %&gt;&lt;%= post.permalink %&gt;&lt;/a&gt;，&lt;a href=&quot;https://&lt;%= config.domain %&gt;&lt;%= post.permalink %&gt;#gitalk-container&quot;&gt;前往原文评论。&lt;/a&gt;&lt;/p&gt;&lt;% } %&gt;</code></pre><p>前往原文评论部分 URL 的 Hash 值请根据你使用的评论系统的 Container ID 修改。<br>然后在 Hexo 的 <code>_config.yml</code> 文件中加入如下配置:</p><pre><code class="lang-yaml">domain: imvictor.tech # 你的域名copyrights: true</code></pre><p>这样可以灵活控制是否打开这个功能，也方便切换域名。</p><h2 id="2-查看-Markdown-源文件"><a href="#2-查看-Markdown-源文件" class="headerlink" title="2. 查看 Markdown 源文件"></a>2. 查看 Markdown 源文件</h2><p>这个灵感最初是来自 imququ.com，再次致敬。<br>在 emlog 中，这个功能实现起来反而更加复杂，因为 emlog 本身不支持 Markdown，我是通过自己的方式来实现 Markdown 支持的。在 emlog 中，为了输出 Markdown 源文件，我使用了一些比较 trick 的方法，就不说了。<br>现在，我几乎没有动 Hexo 就实现了这个功能，因为 nginx 可以很好地完成这个工作。<br>先对 <code>source/_posts/</code> 进行符号链接到 <code>source/posts/</code>。<br>在 nginx 的 Config 文件中加入以下代码:</p><pre><code>location / {    root /home/user/hexo/public/;    location ~* \.(md)$ {        root /home/user/hexo/source/;    }}</code></pre><p>这样在请求 Markdown 文件时会自动到 source 下寻找。<br>e.g.:</p><pre><code class="lang-dontparse">Query: https://imvictor.tech/posts/simulation-of-ppc-macos-via-qemu.mdOutput File: source/posts/simulation-of-ppc-macos-via-qemu.md</code></pre><p>可以根据个人情况修改。<br>在主题的 <code>layout/_partial/article.ejs</code> 中，在 <code>&lt;% post.content %&gt;</code> 之后适当位置加入以下代码:</p><pre><code>&lt;% if (config.mdsource &amp;&amp; page.layout == &quot;post&quot;) { %&gt;    &lt;div style=&quot;margin-right: 1em; text-align: right;&quot;&gt;&lt;a href=&quot;/posts/&lt;%= post.slug %&gt;.md&quot;&gt;查看本文 Markdown 版本 »&lt;/a&gt;&lt;/div&gt;&lt;% } %&gt;</code></pre><p>在 Hexo 的 <code>_config.yml</code> 中加入 <code>mdsource: true</code>。<br>这样就完成了 Hexo 的查看 Markdown 源文件。</p><h2 id="3-Hexo-的部署自动化"><a href="#3-Hexo-的部署自动化" class="headerlink" title="3. Hexo 的部署自动化"></a>3. Hexo 的部署自动化</h2><p>由于我们使用 CentOS 服务器，所有的操作都在服务器上完成。<br>首先我希望在 Git Server 上备份我的 Hexo 博客源文件，也希望能在上面部署一份。这些根据很多人的教程都可以做。我还希望服务器每隔 10 分钟重新生成静态文件。这样，我们可以编写一个脚本。</p><pre><code class="lang-bash">#!/bin/bashHEXOPATH=&quot;# 你的 Hexo 文件夹绝对路径，末尾不带 /&quot;cd $HEXOPATHhexo ggit add $HEXOPATH/* &amp;&amp; git commit -m &quot;Backup at $(date)&quot; &amp;&amp; git push -u origin masterhexo deployexit 0</code></pre><p>在 crontab 中，加入如下代码:</p><pre><code class="lang-cron">*/10 * * * * ~/hexogenerate.sh &gt; /dev/null</code></pre><p>这样服务器就会每隔 10 分钟重建一次静态文件。</p><p>还有一些比如 GitHub Issue 评论系统的部署，这些网上教程也是一大把。我在这里只强调一点: 注意在<code>&lt;meta&gt;</code>头里面加入 AJAX 跨域访问的值项，也没什么坑。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;切换到 Hexo 之后，首要的任务就是把之前的一些轮子再造一遍。  &lt;/p&gt;
&lt;h2 id=&quot;1-版权声明和原文链接&quot;&gt;&lt;a href=&quot;#1-版权声明和原文链接&quot; class=&quot;headerlink&quot; title=&quot;1. 版权声明和原文链接&quot;&gt;&lt;/a&gt;1. 版权声明和原文链接&lt;/h2&gt;&lt;p&gt;在旧的博客中，我曾经加入过这样的功能:&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Chickking-Website/SomeFile/master/201711/sourcemark.png&quot; alt=&quot;版权声明和原文链接&quot;&gt;&lt;br&gt;在 emlog 中，这些非常容易做。而在 Hexo 中，这也不是难事。&lt;br&gt;我使用的是 yilia 主题，在主题的 &lt;code&gt;layout/_partial/article.ejs&lt;/code&gt; 中，在 &lt;code&gt;&amp;lt;% post.content %&amp;gt;&lt;/code&gt; 之后加入以下代码:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;% if (config.copyrights &amp;amp;&amp;amp; page.layout == &amp;quot;post&amp;quot;) { %&amp;gt;
    &amp;lt;hr&amp;gt;
    &amp;lt;p&amp;gt;本文著作权归作者所有，允许非商业性转载使用，但请在转载后文末附上原文链接。&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;原文链接: &amp;lt;a href=&amp;quot;https://&amp;lt;%= config.domain %&amp;gt;&amp;lt;%= post.permalink %&amp;gt;&amp;quot;&amp;gt;https://&amp;lt;%= config.domain %&amp;gt;&amp;lt;%= post.permalink %&amp;gt;&amp;lt;/a&amp;gt;，&amp;lt;a href=&amp;quot;https://&amp;lt;%= config.domain %&amp;gt;&amp;lt;%= post.permalink %&amp;gt;#gitalk-container&amp;quot;&amp;gt;前往原文评论。&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;% } %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;前往原文评论部分 URL 的 Hash 值请根据你使用的评论系统的 Container ID 修改。&lt;br&gt;然后在 Hexo 的 &lt;code&gt;_config.yml&lt;/code&gt; 文件中加入如下配置:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-yaml&quot;&gt;domain: imvictor.tech # 你的域名
copyrights: true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样可以灵活控制是否打开这个功能，也方便切换域名。&lt;/p&gt;
&lt;h2 id=&quot;2-查看-Markdown-源文件&quot;&gt;&lt;a href=&quot;#2-查看-Markdown-源文件&quot; class=&quot;headerlink&quot; title=&quot;2. 查看 Markdown 源文件&quot;&gt;&lt;/a&gt;2. 查看 Markdown 源文件&lt;/h2&gt;&lt;p&gt;这个灵感最初是来自 imququ.com，再次致敬。&lt;br&gt;在 emlog 中，这个功能实现起来反而更加复杂，因为 emlog 本身不支持 Markdown，我是通过自己的方式来实现 Markdown 支持的。在 emlog 中，为了输出 Markdown 源文件，我使用了一些比较 trick 的方法，就不说了。&lt;br&gt;现在，我几乎没有动 Hexo 就实现了这个功能，因为 nginx 可以很好地完成这个工作。&lt;br&gt;先对 &lt;code&gt;source/_posts/&lt;/code&gt; 进行符号链接到 &lt;code&gt;source/posts/&lt;/code&gt;。&lt;br&gt;在 nginx 的 Config 文件中加入以下代码:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;location / {
    root /home/user/hexo/public/;
    location ~* \.(md)$ {
        root /home/user/hexo/source/;
    }
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="网站" scheme="/tags/%E7%BD%91%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>新的开始</title>
    <link href="/posts/a-completely-new-beginning/"/>
    <id>/posts/a-completely-new-beginning/</id>
    <published>2017-10-19T16:00:00.000Z</published>
    <updated>2017-11-29T14:49:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>转眼间，开学已经一个多月了。<br>既然来到了一中，我想一切都应当重新开始了。和过去的自己一刀两断，或许是有必要的吧。那个懒惰、不思进取的自己，也要有所改变了？<br>这个博客的域名从 chickger.pw 换到 imvictor.tech，是一个经过深思熟虑的决定，旧的域名难以记忆，而新的域名则更加便于记忆和展现个性。 As you can see，我也弃暗投明，换用了 Hexo 这个博客系统，和 emlog 彻底说再见。以前只知道一味地缝缝补补，缺乏推倒重来的勇气。此番功夫的目的就是让一切重新开始。<br>而在文化课上，初中三年都是浪过来的我，在进入一中的时候是没有任何优势的。入学时，全班一共 59 个人，我排第 44 名。最低分数线 624，我 628 进来。这种成绩在这里除了艺术生基本就是垫底了。<br>而十一过后月考完了呢？我确信这一个月我只是比从前的自己稍稍多努力了一点点，甚至不比以前努力多少，而取得的成绩确是大不一样的。至于月考成绩出来后从第 44 名蹦到第 9 名，35 个名次。这也许是我中考以来第二个转折点了吧。<br>然而仅仅是月考是远远不够的。今后的内容会更加困难，成绩能不能保得住，还未可知。  </p><p><strong>重新开始</strong>，这四个字就是我现在首要的事情。而竞争只会越来越激烈。那么我只能更加拼命地提升自己了。博客我还会坚持更新，不会放弃。</p><p>每一天又是新的一天，让人期待的一天。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转眼间，开学已经一个多月了。&lt;br&gt;既然来到了一中，我想一切都应当重新开始了。和过去的自己一刀两断，或许是有必要的吧。那个懒惰、不思进取的自己，也要有所改变了？&lt;br&gt;这个博客的域名从 chickger.pw 换到 imvictor.tech，是一个经过深思熟虑的决定，旧的域名难以记忆，而新的域名则更加便于记忆和展现个性。 As you can see，我也弃暗投明，换用了 Hexo 这个博客系统，和 emlog 彻底说再见。以前只知道一味地缝缝补补，缺乏推倒重来的勇气。此番功夫的目的就是让一切重新开始。&lt;br&gt;而在文化课上，初中三年都是浪过来的我，在进入一中的时候是没有任何优势的。入学时，全班一共 59 个人，我排第 44 名。最低分数线 624，我 628 进来。这种成绩在这里除了艺术生基本就是垫底了。&lt;br&gt;而十一过后月考完了呢？我确信这一个月我只是比从前的自己稍稍多努力了一点点，甚至不比以前努力多少，而取得的成绩确是大不一样的。至于月考成绩出来后从第 44 名蹦到第 9 名，35 个名次。这也许是我中考以来第二个转折点了吧。&lt;br&gt;然而仅仅是月考是远远不够的。今后的内容会更加困难，成绩能不能保得住，还未可知。  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重新开始&lt;/strong&gt;，这四个字就是我现在首要的事情。而竞争只会越来越激烈。那么我只能更加拼命地提升自己了。博客我还会坚持更新，不会放弃。&lt;/p&gt;
&lt;p&gt;每一天又是新的一天，让人期待的一天。&lt;/p&gt;

    
    </summary>
    
    
      <category term="碎碎念" scheme="/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>使用 QEMU 模拟 PowerPC 版本的 Mac OS X / Classic Mac OS</title>
    <link href="/posts/simulation-of-ppc-macos-via-qemu/"/>
    <id>/posts/simulation-of-ppc-macos-via-qemu/</id>
    <published>2017-09-13T04:26:13.000Z</published>
    <updated>2018-08-18T07:53:29.461Z</updated>
    
    <content type="html"><![CDATA[<p>首先要说声抱歉，由于我已经升入高中并且主打文化课，博文可能很难保持长期的更新。这篇博文涉及的东西早在一周前就已经做完，但一直拖着直到今天才开始写。话不多说，进入主题吧。</p><h2 id="1-准备镜像"><a href="#1-准备镜像" class="headerlink" title="1. 准备镜像"></a>1. 准备镜像</h2><p>我们要模拟 PowerPC 版本的 Mac OS X，所以要准备好对应版本的 Mac OS X 的镜像。我发现有一个叫做 <a href="http://macintoshgarden.org/" target="_blank" rel="noopener">MacintoshGarden.org</a> 的网站，收集了许多旧版本 Mac OS X / Classic Mac OS 的资源。大家可以先下载着。</p><h2 id="2-QEMU-版本下载"><a href="#2-QEMU-版本下载" class="headerlink" title="2. QEMU 版本下载"></a>2. QEMU 版本下载</h2><p>模拟 Mac OS X 10.4 之前的版本，只需要下载标准版本的  qemu-system-ppc 即可。只需要通过 brew 安装即可。这里给出 Emaculation.com 提供的 QEMU 的 <a href="http://www.emaculation.com/forum/viewtopic.php?f=34&amp;t=9028" target="_blank" rel="noopener">Windows 版本</a>和 <a href="http://www.emaculation.com/forum/viewtopic.php?f=34&amp;t=8848" target="_blank" rel="noopener">macOS 版本</a>。只需要安装置顶的版本即可。qemu.command 可配置如下 (Windows 用户请根据实际使用 Shell 情况修改):</p><pre><code class="lang-bash">#!/bin/bashcd &quot;$(dirname &quot;$0&quot;)&quot;./qemu-system-ppc -hda osx_cheetah.qcow2 -hdb swap.img -cdrom cheetah.iso -m 512 -boot c -net nic,model=e1000 -net user</code></pre><p>其中，-hda、-hdb 设置的是内置硬盘的镜像，-cdrom 是设置光盘镜像的路径。-m 是 RAM 的大小(以 MB 为单位)。而 -boot 则是第一启动项设置，c 为硬盘，d 为光盘。后面的 -net 是指网络配置，无需修改。<br>而对于 Mac OS X 10.4 以及以上版本，我们需要一个特殊版本的支持 mac99p 机型的 QEMU，由于我使用的是 macOS，故无法提供 Windows 版本。Mac 版本的下载我已经上传 CDN 了。下载地址在<a href="https://static.chickger.pw/201709/qemu-mac99p.zip" target="_blank" rel="noopener">这里</a>。<br>这个版本我没有内置 qemu.command，需要进行如下配置:</p><pre><code class="lang-bash">#!/bin/bashcd &quot;$(dirname &quot;$0&quot;)&quot;./qemu-system-ppc-wip -bios openbios-qemu-wip.elf -L pc-bios -boot c -m 1024 -M mac99p -prom-env &quot;auto-boot?=true&quot; -net nic,model=e1000 -net user -hda osx_tiger.qcow2 -hdb swap.img</code></pre><p>其中，-bios 是设置特殊的 BIOS 文件。而 -M 则是设置机型，Mac OS X Tiger 要求至少是 G4 的 Mac，所以机型设置为 mac99p。而 -prom-env 则是在 NVRAM 中写入参数，比如如果你需要 -v 啰嗦启动，则加入 <code>-prom-env &quot;boot-args=-v&quot;</code>。</p><h2 id="3-虚拟硬盘镜像生成"><a href="#3-虚拟硬盘镜像生成" class="headerlink" title="3. 虚拟硬盘镜像生成"></a>3. 虚拟硬盘镜像生成</h2><p>QEMU 需要你手动生成虚拟硬盘镜像，这里我们使用 QEMU 发布的实用工具生成镜像。<br>其中，虚拟硬盘镜像格式很多，常用的有 RAW、qcow2 等。如果要生成一个大小为 10 GB 的 RAW 镜像，则执行命令为:</p><pre><code class="lang-bash">qemu-img -f raw -O size=10G Filename.img</code></pre><p>RAW 镜像的优点在于 macOS 可以直接挂载(如果文件系统受支持)。缺点是占空间大，即使是空白镜像也要写入所有的 0。空间不能动态调节。<br>而 qcow2 镜像的优点在于按需占用空间，而不是一次性分配。在没有写入内容时只占用很小的空间，而占用空间的大小取决于你装入的数据的多少。缺点是 macOS 不能直接识别这种格式，挂载不是很方便。如果生成一个 10 GB 的 qcow2 镜像，则执行命令为:</p><pre><code class="lang-bash">qemu-img -f qcow2 -O size=10G Filename.qcow2</code></pre><h2 id="4-安装操作系统"><a href="#4-安装操作系统" class="headerlink" title="4. 安装操作系统"></a>4. 安装操作系统</h2><p>上面全部配置完成，就可以安装了。这个由于涉及到跨架构模拟，性能损失可能比较严重。因此，请务必耐心充足。<br>你可以看看 QEMU 的帮助文档，发现更多有用、有趣的配置项，让你的 Mac OS 更加出彩。<br>下面贴一张 Mac OS X v10.0 “Cheetah”  的运行图片:</p><p><img src="https://static.chickger.pw/201709/cheetah.png" alt="Mac OS X Cheetah"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先要说声抱歉，由于我已经升入高中并且主打文化课，博文可能很难保持长期的更新。这篇博文涉及的东西早在一周前就已经做完，但一直拖着直到今天才开始写。话不多说，进入主题吧。&lt;/p&gt;
&lt;h2 id=&quot;1-准备镜像&quot;&gt;&lt;a href=&quot;#1-准备镜像&quot; class=&quot;headerlink&quot; title=&quot;1. 准备镜像&quot;&gt;&lt;/a&gt;1. 准备镜像&lt;/h2&gt;&lt;p&gt;我们要模拟 PowerPC 版本的 Mac OS X，所以要准备好对应版本的 Mac OS X 的镜像。我发现有一个叫做 &lt;a href=&quot;http://macintoshgarden.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MacintoshGarden.org&lt;/a&gt; 的网站，收集了许多旧版本 Mac OS X / Classic Mac OS 的资源。大家可以先下载着。&lt;/p&gt;
&lt;h2 id=&quot;2-QEMU-版本下载&quot;&gt;&lt;a href=&quot;#2-QEMU-版本下载&quot; class=&quot;headerlink&quot; title=&quot;2. QEMU 版本下载&quot;&gt;&lt;/a&gt;2. QEMU 版本下载&lt;/h2&gt;&lt;p&gt;模拟 Mac OS X 10.4 之前的版本，只需要下载标准版本的  qemu-system-ppc 即可。只需要通过 brew 安装即可。这里给出 Emaculation.com 提供的 QEMU 的 &lt;a href=&quot;http://www.emaculation.com/forum/viewtopic.php?f=34&amp;amp;t=9028&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Windows 版本&lt;/a&gt;和 &lt;a href=&quot;http://www.emaculation.com/forum/viewtopic.php?f=34&amp;amp;t=8848&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;macOS 版本&lt;/a&gt;。只需要安装置顶的版本即可。qemu.command 可配置如下 (Windows 用户请根据实际使用 Shell 情况修改):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;#!/bin/bash
cd &amp;quot;$(dirname &amp;quot;$0&amp;quot;)&amp;quot;
./qemu-system-ppc -hda osx_cheetah.qcow2 -hdb swap.img -cdrom cheetah.iso -m 512 -boot c -net nic,model=e1000 -net user
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中，-hda、-hdb 设置的是内置硬盘的镜像，-cdrom 是设置光盘镜像的路径。-m 是 RAM 的大小(以 MB 为单位)。而 -boot 则是第一启动项设置，c 为硬盘，d 为光盘。后面的 -net 是指网络配置，无需修改。&lt;br&gt;而对于 Mac OS X 10.4 以及以上版本，我们需要一个特殊版本的支持 mac99p 机型的 QEMU，由于我使用的是 macOS，故无法提供 Windows 版本。Mac 版本的下载我已经上传 CDN 了。下载地址在&lt;a href=&quot;https://static.chickger.pw/201709/qemu-mac99p.zip&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;。&lt;br&gt;这个版本我没有内置 qemu.command，需要进行如下配置:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;#!/bin/bash
cd &amp;quot;$(dirname &amp;quot;$0&amp;quot;)&amp;quot;
./qemu-system-ppc-wip -bios openbios-qemu-wip.elf -L pc-bios -boot c -m 1024 -M mac99p -prom-env &amp;quot;auto-boot?=true&amp;quot; -net nic,model=e1000 -net user -hda osx_tiger.qcow2 -hdb swap.img
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中，-bios 是设置特殊的 BIOS 文件。而 -M 则是设置机型，Mac OS X Tiger 要求至少是 G4 的 Mac，所以机型设置为 mac99p。而 -prom-env 则是在 NVRAM 中写入参数，比如如果你需要 -v 啰嗦启动，则加入 &lt;code&gt;-prom-env &amp;quot;boot-args=-v&amp;quot;&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;3-虚拟硬盘镜像生成&quot;&gt;&lt;a href=&quot;#3-虚拟硬盘镜像生成&quot; class=&quot;headerlink&quot; title=&quot;3. 虚拟硬盘镜像生成&quot;&gt;&lt;/a&gt;3. 虚拟硬盘镜像生成&lt;/h2&gt;
    
    </summary>
    
    
      <category term="苹果" scheme="/tags/%E8%8B%B9%E6%9E%9C/"/>
    
      <category term="Hack" scheme="/tags/Hack/"/>
    
      <category term="黑苹果" scheme="/tags/%E9%BB%91%E8%8B%B9%E6%9E%9C/"/>
    
      <category term="macOS" scheme="/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>校园网 Dr.COM 认证路由器一键安装脚本</title>
    <link href="/posts/drcom-auto-login-script/"/>
    <id>/posts/drcom-auto-login-script/</id>
    <published>2017-07-24T14:11:51.000Z</published>
    <updated>2017-11-04T06:00:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>咳咳，消失了这么久，也没人想我，发条评论了，好桑心啊。呜呜呜……<br>中考结束了，先和 friend 一起去了趟北京，Apple Store 好大气啊，还有小米之家，真的好棒。回来之后发现考的不是很好但是如愿以偿上了一中，然后就跑到表姐那边一起开始上神奇的衔接班。<br>然后就沉迷于各种 Game 和 Video 中无法自拔，以至于半个月前就写好要发布了的脚本延期了……<br>言归正传，我先上脚本。</p><h2 id="1-编写与执行环境"><a href="#1-编写与执行环境" class="headerlink" title="1. 编写与执行环境"></a>1. 编写与执行环境</h2><p>该脚本采用 UTF-8 编码，在我搭载 macOS Sierra 10.12.5 的 MacBook Pro 上通过 Sublime Text 写成。测试和使用环境为<strong>极路由4增强版</strong>。</p><h2 id="2-下载和使用"><a href="#2-下载和使用" class="headerlink" title="2. 下载和使用"></a>2. 下载和使用</h2><p>首先，我把这个项目放到了 GitHub 上，去把项目下载了就行了。<br>另外，README.md 是用英语写的，这个不是大问题，我试了下，我那很烂的英语你们用 Google 翻译了之后稍微对照原文一定能看懂。<br>链接: <a href="https://github.com/Chickking/Hiwifi-Drcom" target="_blank" rel="external">https://github.com/Chickking/Hiwifi-Drcom</a></p><h2 id="3-附赠品"><a href="#3-附赠品" class="headerlink" title="3. 附赠品"></a>3. 附赠品</h2><p>自己封装的一个 Mac 客户端，也是基于 drcom-generic。<br>GitHub 地址: <a href="https://github.com/Chickking/PythonDrcom" target="_blank" rel="external">https://github.com/Chickking/PythonDrcom</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;咳咳，消失了这么久，也没人想我，发条评论了，好桑心啊。呜呜呜……&lt;br&gt;中考结束了，先和 friend 一起去了趟北京，Apple Store 好大气啊，还有小米之家，真的好棒。回来之后发现考的不是很好但是如愿以偿上了一中，然后就跑到表姐那边一起开始上神奇的衔接班。&lt;br&gt;然后就沉迷于各种 Game 和 Video 中无法自拔，以至于半个月前就写好要发布了的脚本延期了……&lt;br&gt;言归正传，我先上脚本。&lt;/p&gt;
&lt;h2 id=&quot;1-编写与执行环境&quot;&gt;&lt;a href=&quot;#1-编写与执行环境&quot; class=&quot;headerlink&quot; title=&quot;1. 编写与执行环境&quot;&gt;&lt;/a&gt;1. 编写与执行环境&lt;/h2&gt;&lt;p&gt;该脚本采用 UTF-8 编码，在我搭载 macOS Sierra 10.12.5 的 MacBook Pro 上通过 Sublime Text 写成。测试和使用环境为&lt;strong&gt;极路由4增强版&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;2-下载和使用&quot;&gt;&lt;a href=&quot;#2-下载和使用&quot; class=&quot;headerlink&quot; title=&quot;2. 下载和使用&quot;&gt;&lt;/a&gt;2. 下载和使用&lt;/h2&gt;&lt;p&gt;首先，我把这个项目放到了 GitHub 上，去把项目下载了就行了。&lt;br&gt;另外，README.md 是用英语写的，这个不是大问题，我试了下，我那很烂的英语你们用 Google 翻译了之后稍微对照原文一定能看懂。&lt;br&gt;链接: &lt;a href=&quot;https://github.com/Chickking/Hiwifi-Drcom&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/Chickking/Hiwifi-Drcom&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;3-附赠品&quot;&gt;&lt;a href=&quot;#3-附赠品&quot; class=&quot;headerlink&quot; title=&quot;3. 附赠品&quot;&gt;&lt;/a&gt;3. 附赠品&lt;/h2&gt;&lt;p&gt;自己封装的一个 Mac 客户端，也是基于 drcom-generic。&lt;br&gt;GitHub 地址: &lt;a href=&quot;https://github.com/Chickking/PythonDrcom&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/Chickking/PythonDrcom&lt;/a&gt;&lt;/p&gt;

    
    </summary>
    
    
      <category term="Linux" scheme="/tags/Linux/"/>
    
      <category term="Hack" scheme="/tags/Hack/"/>
    
      <category term="macOS" scheme="/tags/macOS/"/>
    
      <category term="Python" scheme="/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>让旧的 iPhone 成为服务器</title>
    <link href="/posts/turn-an-old-iPhone-into-a-server/"/>
    <id>/posts/turn-an-old-iPhone-into-a-server/</id>
    <published>2017-04-25T13:21:12.000Z</published>
    <updated>2018-08-18T07:53:29.463Z</updated>
    
    <content type="html"><![CDATA[<p>最近家里的一台服役了 13 年的老笔记本退役了，本来是作为家里校园网 Dr.COM 验证的专用机器 + 内网 Web 服务器的。对于笔记本运行发出的噪音的不满，我决定不使用笔记本电脑或台式机来接替它，而是使用 iPhone。  </p><h2 id="0-Dr-COM-验证程序"><a href="#0-Dr-COM-验证程序" class="headerlink" title="0. Dr.COM 验证程序"></a>0. Dr.COM 验证程序</h2><h3 id="a-程序本身的配置"><a href="#a-程序本身的配置" class="headerlink" title="a. 程序本身的配置"></a>a. 程序本身的配置</h3><p>最近闲逛 GitHub 时发现了一个可以直接用的 Dr.COM 认证的 Python 项目，而且也可以配合路由器使用，叫做 <a href="https://github.com/drcoms/drcom-generic" target="_blank" rel="noopener">drcom_generic</a>。<br><strong><span style="color: red;">注: 建议大家直接去看该项目的 wiki，这里的 Dr.COM 配置方法不一定适合每一个校园网的网络环境。</span></strong><br>首先我们 Clone 下来这个项目，然后我们不需要别的，先用 Wireshark 抓一下原版客户端登录的包，保存为 dump.pcapang。<br>然后打开 Auto Configure 工具，上传 pcapang 包，即可生成你独有的配置文件。<br>Example:</p><pre><code>server = &#39;192.168.88.66&#39;username = &#39;123456&#39;password = &#39;pass000&#39;CONTROLCHECKSTATUS = &#39;\x20&#39;ADAPTERNUM = &#39;\x01&#39;host_ip = &#39;127.0.0.1&#39;IPDOG = &#39;\x01&#39;host_name = &#39;foo&#39;PRIMARY_DNS = &#39;192.168.0.1&#39;dhcp_server = &#39;0.0.0.0&#39;AUTH_VERSION = &#39;\x0f\x00&#39;mac = 0x00aabbccddeehost_os = &#39;Windows 10&#39;KEEP_ALIVE_VERSION = &#39;\xdc\x02&#39;ror_version = False</code></pre><p>这时候我们把项目文件夹下的 latest-wired.py 拷贝出来，并命名为 Drcom.py。<br>找到 <code># CONFIG</code> 和 <code># CONFIG_END</code> 之间的部分，把这一部分换成你自己的配置。(截止到2017年4月25日，这一部分是第13行到第32行)<br>如果这样就运行，会产生 log 文件，长期这样这个文件会很大，我们可以设置 LOG_PATH 来规避这个问题。找到整段代码中两处 LOG_PATH 的值(第81行~第84行)，并设置为:</p><pre><code class="lang-python">LOG_PATH = &#39;/dev/null&#39;if IS_TEST:    DEBUG = True    LOG_PATH = &#39;/dev/null&#39;</code></pre><p>注: 如果是用 Windows 的同学想在电脑上跑这个 Python 脚本，可以把 LOG_PATH 设置为 <code>NUL</code>。<br>这样文件本身的修改配置就做完了。</p><h3 id="b-iPhone-环境配置"><a href="#b-iPhone-环境配置" class="headerlink" title="b. iPhone 环境配置"></a>b. iPhone 环境配置</h3><p>首先我们需要一台越狱的 iPhone，版本任意。<br>在 Cydia 里面先安装上 <code>MobileTerminal</code>、<code>MobileTerm Backgrounder</code>、<code>Core Utilities</code>等。<br>Cydia/Telesphoreo 源里面的 Python 不要装，版本比较老，我发现 Linus Yang 大神写了一个 Python 2.7.6 的 deb 插件，可以去 GitHub 上<a href="https://github.com/linusyang/python-for-ios" target="_blank" rel="noopener">围观</a>一下。我这里也提供直连的<a href="https://github.com/linusyang/python-for-ios/releases/download/v2.7.6-3/python_2.7.6-3_iphoneos-arm.deb" target="_blank" rel="noopener">下载地址</a>。<br>安装好 Python，就可以把脚本放在这上面跑了。需要注意的是，作为服务器，应当尽可能的使其实现最大化的自动化，而这个脚本一旦断线是不会自动重连的。所以我们可以写一个  Shell 死循环，使其重复执行。<br>这里有同学会提问题: 那么如果我们想关掉它怎么办，<code>killall bash &amp;&amp; killall python</code> 会把我们当前操作的终端也一起关闭啊？这个问题可以简单粗暴地解决，即建立 bash 的软链接，取另一个名字，然后让其解释执行我们的脚本。代码如下:</p><pre><code class="lang-bash">#!/bin/abcshfor((i=1;i&lt;=10;i=i));dopython /var/mobile/Drcom.pydone</code></pre><p>可以看出，我们建立了一个 bash 的软链接为 <code>/bin/abcsh</code>，这样当我们想要关闭 Dr.COM 验证程序时只需要一行 <code>killall abcsh &amp;&amp; killall python</code> 即可。  </p><h2 id="1-Web-Server-的配置"><a href="#1-Web-Server-的配置" class="headerlink" title="1. Web Server 的配置"></a>1. Web Server 的配置</h2><p>iPhone 上运行 Web Server，最省资源的方式就是使用 lighttpd。</p><p>lighttpd 的配置方式非常简单，首先我们从 Cydia 中下载这个插件，然后在终端启动即可，不多说了，直接上配置。</p><pre><code>server.document-root = &quot;/var/mobile/Documents/www&quot; server.port = 80server.username = &quot;mobile&quot;mimetype.assign = (  &quot;.html&quot; =&gt; &quot;text/html; charset=utf-8&quot;,  &quot;.htm&quot; =&gt; &quot;text/html; charset=utf-8&quot;,  &quot;.css&quot; =&gt; &quot;text/css; charset=utf-8&quot;,  &quot;.js&quot; =&gt; &quot;text/javascript; charset=utf-8&quot;,  &quot;.txt&quot; =&gt; &quot;text/plain; charset=utf-8&quot;,  &quot;.jpg&quot; =&gt; &quot;image/jpeg&quot;,  &quot;.png&quot; =&gt; &quot;image/png&quot;,  &quot;&quot; =&gt; &quot;application/octet-stream; charset=utf-8&quot;)dir-listing.activate = &quot;enable&quot; dir-listing.encoding = &quot;utf-8&quot;index-file.names = ( &quot;index.html&quot; )</code></pre><p>将配置文件保存到 /etc/lighttpd.conf。</p><h2 id="2-维护相关"><a href="#2-维护相关" class="headerlink" title="2. 维护相关"></a>2. 维护相关</h2><p>iPhone 服务器相对来说较容易维护，我使用 Veency + OpenSSH 来维护 iPhone 服务器。<br>Veency 是 iPhone 上的 VNC Server，可以让你通过 VNC 来控制 iPhone，大家下载了就知道。<br>给大家看看 Veency 的效果:<br><img src="https://static.chickger.pw/201704/iPhoneVeency.png" alt="Veency on iPhone"><br>OpenSSH 不必多说，诸位老司机都懂，但切记要把 root 密码 alpine 改掉，不然你的 iPhone 就不是你的了。<br>vsftpd 也有必要，这主要用于 iPhone Web Server 上资源下载目录的上传操作，直接上配置吧。路径: /etc/vsftpd.conf</p><pre><code>local_root=/var/mobile/Documents/down/anon_root= /usr/share/emptylisten=YESbackground=YESlocal_enable=YESwrite_enable=YESftp_username=uploadftp_password=upload</code></pre><h2 id="3-结语"><a href="#3-结语" class="headerlink" title="3. 结语"></a>3. 结语</h2><p>iPhone 作为服务器还是十分给力的，首先配置相对大多数服务器要高，而且功耗小，运行无声音，发热也小，很适合扮演家庭服务器的角色。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近家里的一台服役了 13 年的老笔记本退役了，本来是作为家里校园网 Dr.COM 验证的专用机器 + 内网 Web 服务器的。对于笔记本运行发出的噪音的不满，我决定不使用笔记本电脑或台式机来接替它，而是使用 iPhone。  &lt;/p&gt;
&lt;h2 id=&quot;0-Dr-COM-验证程序&quot;&gt;&lt;a href=&quot;#0-Dr-COM-验证程序&quot; class=&quot;headerlink&quot; title=&quot;0. Dr.COM 验证程序&quot;&gt;&lt;/a&gt;0. Dr.COM 验证程序&lt;/h2&gt;&lt;h3 id=&quot;a-程序本身的配置&quot;&gt;&lt;a href=&quot;#a-程序本身的配置&quot; class=&quot;headerlink&quot; title=&quot;a. 程序本身的配置&quot;&gt;&lt;/a&gt;a. 程序本身的配置&lt;/h3&gt;&lt;p&gt;最近闲逛 GitHub 时发现了一个可以直接用的 Dr.COM 认证的 Python 项目，而且也可以配合路由器使用，叫做 &lt;a href=&quot;https://github.com/drcoms/drcom-generic&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;drcom_generic&lt;/a&gt;。&lt;br&gt;&lt;strong&gt;&lt;span style=&quot;color: red;&quot;&gt;注: 建议大家直接去看该项目的 wiki，这里的 Dr.COM 配置方法不一定适合每一个校园网的网络环境。&lt;/span&gt;&lt;/strong&gt;&lt;br&gt;首先我们 Clone 下来这个项目，然后我们不需要别的，先用 Wireshark 抓一下原版客户端登录的包，保存为 dump.pcapang。&lt;br&gt;然后打开 Auto Configure 工具，上传 pcapang 包，即可生成你独有的配置文件。&lt;br&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server = &amp;#39;192.168.88.66&amp;#39;
username = &amp;#39;123456&amp;#39;
password = &amp;#39;pass000&amp;#39;
CONTROLCHECKSTATUS = &amp;#39;\x20&amp;#39;
ADAPTERNUM = &amp;#39;\x01&amp;#39;
host_ip = &amp;#39;127.0.0.1&amp;#39;
IPDOG = &amp;#39;\x01&amp;#39;
host_name = &amp;#39;foo&amp;#39;
PRIMARY_DNS = &amp;#39;192.168.0.1&amp;#39;
dhcp_server = &amp;#39;0.0.0.0&amp;#39;
AUTH_VERSION = &amp;#39;\x0f\x00&amp;#39;
mac = 0x00aabbccddee
host_os = &amp;#39;Windows 10&amp;#39;
KEEP_ALIVE_VERSION = &amp;#39;\xdc\x02&amp;#39;
ror_version = False
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这时候我们把项目文件夹下的 latest-wired.py 拷贝出来，并命名为 Drcom.py。&lt;br&gt;找到 &lt;code&gt;# CONFIG&lt;/code&gt; 和 &lt;code&gt;# CONFIG_END&lt;/code&gt; 之间的部分，把这一部分换成你自己的配置。(截止到2017年4月25日，这一部分是第13行到第32行)&lt;br&gt;如果这样就运行，会产生 log 文件，长期这样这个文件会很大，我们可以设置 LOG_PATH 来规避这个问题。找到整段代码中两处 LOG_PATH 的值(第81行~第84行)，并设置为:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-python&quot;&gt;LOG_PATH = &amp;#39;/dev/null&amp;#39;
if IS_TEST:
    DEBUG = True
    LOG_PATH = &amp;#39;/dev/null&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注: 如果是用 Windows 的同学想在电脑上跑这个 Python 脚本，可以把 LOG_PATH 设置为 &lt;code&gt;NUL&lt;/code&gt;。&lt;br&gt;这样文件本身的修改配置就做完了。&lt;/p&gt;
&lt;h3 id=&quot;b-iPhone-环境配置&quot;&gt;&lt;a href=&quot;#b-iPhone-环境配置&quot; class=&quot;headerlink&quot; title=&quot;b. iPhone 环境配置&quot;&gt;&lt;/a&gt;b. iPhone 环境配置&lt;/h3&gt;&lt;p&gt;首先我们需要一台越狱的 iPhone，版本任意。&lt;br&gt;在 Cydia 里面先安装上 &lt;code&gt;MobileTerminal&lt;/code&gt;、&lt;code&gt;MobileTerm Backgrounder&lt;/code&gt;、&lt;code&gt;Core Utilities&lt;/code&gt;等。&lt;br&gt;Cydia/Telesphoreo 源里面的 Python 不要装，版本比较老，我发现 Linus Yang 大神写了一个 Python 2.7.6 的 deb 插件，可以去 GitHub 上&lt;a href=&quot;https://github.com/linusyang/python-for-ios&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;围观&lt;/a&gt;一下。我这里也提供直连的&lt;a href=&quot;https://github.com/linusyang/python-for-ios/releases/download/v2.7.6-3/python_2.7.6-3_iphoneos-arm.deb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;下载地址&lt;/a&gt;。&lt;br&gt;安装好 Python，就可以把脚本放在这上面跑了。需要注意的是，作为服务器，应当尽可能的使其实现最大化的自动化，而这个脚本一旦断线是不会自动重连的。所以我们可以写一个  Shell 死循环，使其重复执行。&lt;br&gt;这里有同学会提问题: 那么如果我们想关掉它怎么办，&lt;code&gt;killall bash &amp;amp;&amp;amp; killall python&lt;/code&gt; 会把我们当前操作的终端也一起关闭啊？这个问题可以简单粗暴地解决，即建立 bash 的软链接，取另一个名字，然后让其解释执行我们的脚本。代码如下:&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hack" scheme="/tags/Hack/"/>
    
      <category term="Python" scheme="/tags/Python/"/>
    
      <category term="iPhone" scheme="/tags/iPhone/"/>
    
      <category term="iOS" scheme="/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>更好的 Markdown for emlog 解决方案</title>
    <link href="/posts/a-better-solution-of-markdown-support-for-emlog/"/>
    <id>/posts/a-better-solution-of-markdown-support-for-emlog/</id>
    <published>2017-03-26T04:36:42.000Z</published>
    <updated>2018-08-18T07:53:29.456Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇博文说到了让 emlog 支持 Markdown，但是在实际应用中我发现效果并不是非常理想，如在文章中输入<code>\r</code>会换行，以及不支持页面的 Markdown Parse。于是想去改进一下，读了 Editor.md 的文档，我决定基于 Editor.md 实现 Markdown 的 Parser。</p><h2 id="1-安装并配置-Editor-md"><a href="#1-安装并配置-Editor-md" class="headerlink" title="1.安装并配置 Editor.md"></a>1.安装并配置 Editor.md</h2><p>安装 Editor.md 十分简单，我就不多说了，大家都会的。<br>重点在于配置 Editor.md，如何配置呢？这取决于你需要怎样的功能，这里推荐你去看看它的 <a href="https://pandao.github.io/editor.md/examples/index.html" target="_blank" rel="noopener">Examples</a>。<br>我的需求是 HTML in Markdown、TOC、以及输出 HTML，流程图和时序图以后恐怕也会用到。我的配置如下:</p><pre><code class="lang-html">        &lt;script type=&quot;text/javascript&quot;&gt;            var testEditor;            $(function() {                testEditor = editormd(&quot;test-editormd&quot;, {                    width   : &quot;100%&quot;,                    height  : 640,                    syncScrolling : &quot;single&quot;,                    htmlDecode : true,                    sequenceDiagram : true,                    flowChart : true,                    saveHTMLToTextarea : true,                    tocm : true,                    tocContainer : &quot;&quot;,                    tocDropdown   : false,                    path    : &quot;https://static.chickger.pw/js/editor.md/lib/&quot;                });            });        &lt;/script&gt;</code></pre><h2 id="2-添加-Parser"><a href="#2-添加-Parser" class="headerlink" title="2.添加 Parser"></a>2.添加 Parser</h2><p>首先，我们在 emlog 的<code>admin/views</code>中上一个博文提到的四个 php 文件中 form 里的合适位置处插入一个 <code>&lt;textarea&gt;</code>，并命名其 name 和 id 为 <code>content</code>。通过审查元素我们发现: Editor.md 的 Markdown Preview Div 的 ClassName 为 <code>markdown-body editormd-preview-container</code>，且整个编辑界面 HTML DOM 树中拥有此 ClassName 的有且只有这一个。所以我们可以通过令这个 <code>&lt;textarea&gt;</code> 的 <code>innerText</code> 属性等于 Preview Div 的 <code>innerHTML</code> 属性来实现 Parse。于是代码如下:</p><pre><code class="lang-javascript">var applyer = document.getElementById(&#39;content&#39;);var source = document.getElementsByClassName(&#39;markdown-body editormd-preview-container&#39;)[0];applyer.innerText = source.innerHTML;</code></pre><h2 id="3-获取-Markdown-原文"><a href="#3-获取-Markdown-原文" class="headerlink" title="3.获取 Markdown 原文"></a>3.获取 Markdown 原文</h2><p>由于 emlog 本身不支持 Markdown，所以我通过 github 转存 Markdown 文件，而 Parse 后无法获取源文件，不够方便，于是可以判断如果文章发表时间在第一篇 Markdown 文章之后则去 github 获取 Markdown 原文并进行 HTML 转义。代码如下:</p><pre><code>&lt;textarea class=&quot;editormd-markdown-textarea&quot; style=&quot;display:none;&quot;&gt;&lt;?php $logDay = gmdate(&#39;Y-n-j&#39;, $date);$logSec = strtotime($logDay);if ($logSec &gt; 1476439200) echo htmlspecialchars(file_get_contents(&quot;https://chickking-website.github.io/Blog-MD/&quot; . &#39;post-&#39; . $_GET[&#39;gid&#39;] . &#39;.md&#39;)); else echo $content; ?&gt;&lt;/textarea&gt;</code></pre><p>而且这样还实现了我修改文章无需复制修改后的原文去管理后台，只要 push 到 GitHub 后打开管理后台之后保存即可。<br>这样就近乎完美实现了 emlog 支持 Markdown 这一目标。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇博文说到了让 emlog 支持 Markdown，但是在实际应用中我发现效果并不是非常理想，如在文章中输入&lt;code&gt;\r&lt;/code&gt;会换行，以及不支持页面的 Markdown Parse。于是想去改进一下，读了 Editor.md 的文档，我决定基于 Editor.md 实现 Markdown 的 Parser。&lt;/p&gt;
&lt;h2 id=&quot;1-安装并配置-Editor-md&quot;&gt;&lt;a href=&quot;#1-安装并配置-Editor-md&quot; class=&quot;headerlink&quot; title=&quot;1.安装并配置 Editor.md&quot;&gt;&lt;/a&gt;1.安装并配置 Editor.md&lt;/h2&gt;&lt;p&gt;安装 Editor.md 十分简单，我就不多说了，大家都会的。&lt;br&gt;重点在于配置 Editor.md，如何配置呢？这取决于你需要怎样的功能，这里推荐你去看看它的 &lt;a href=&quot;https://pandao.github.io/editor.md/examples/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Examples&lt;/a&gt;。&lt;br&gt;我的需求是 HTML in Markdown、TOC、以及输出 HTML，流程图和时序图以后恐怕也会用到。我的配置如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-html&quot;&gt;        &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
            var testEditor;

            $(function() {
                testEditor = editormd(&amp;quot;test-editormd&amp;quot;, {
                    width   : &amp;quot;100%&amp;quot;,
                    height  : 640,
                    syncScrolling : &amp;quot;single&amp;quot;,
                    htmlDecode : true,
                    sequenceDiagram : true,
                    flowChart : true,
                    saveHTMLToTextarea : true,
                    tocm : true,
                    tocContainer : &amp;quot;&amp;quot;,
                    tocDropdown   : false,
                    path    : &amp;quot;https://static.chickger.pw/js/editor.md/lib/&amp;quot;
                });
            });
        &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;2-添加-Parser&quot;&gt;&lt;a href=&quot;#2-添加-Parser&quot; class=&quot;headerlink&quot; title=&quot;2.添加 Parser&quot;&gt;&lt;/a&gt;2.添加 Parser&lt;/h2&gt;&lt;p&gt;首先，我们在 emlog 的&lt;code&gt;admin/views&lt;/code&gt;中上一个博文提到的四个 php 文件中 form 里的合适位置处插入一个 &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt;，并命名其 name 和 id 为 &lt;code&gt;content&lt;/code&gt;。通过审查元素我们发现: Editor.md 的 Markdown Preview Div 的 ClassName 为 &lt;code&gt;markdown-body editormd-preview-container&lt;/code&gt;，且整个编辑界面 HTML DOM 树中拥有此 ClassName 的有且只有这一个。所以我们可以通过令这个 &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; 的 &lt;code&gt;innerText&lt;/code&gt; 属性等于 Preview Div 的 &lt;code&gt;innerHTML&lt;/code&gt; 属性来实现 Parse。于是代码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;var applyer = document.getElementById(&amp;#39;content&amp;#39;);
var source = document.getElementsByClassName(&amp;#39;markdown-body editormd-preview-container&amp;#39;)[0];
applyer.innerText = source.innerHTML;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;3-获取-Markdown-原文&quot;&gt;&lt;a href=&quot;#3-获取-Markdown-原文&quot; class=&quot;headerlink&quot; title=&quot;3.获取 Markdown 原文&quot;&gt;&lt;/a&gt;3.获取 Markdown 原文&lt;/h2&gt;&lt;p&gt;由于 emlog 本身不支持 Markdown，所以我通过 github 转存 Markdown 文件，而 Parse 后无法获取源文件，不够方便，于是可以判断如果文章发表时间在第一篇 Markdown 文章之后则去 github 获取 Markdown 原文并进行 HTML 转义。代码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;textarea class=&amp;quot;editormd-markdown-textarea&amp;quot; style=&amp;quot;display:none;&amp;quot;&amp;gt;&amp;lt;?php $logDay = gmdate(&amp;#39;Y-n-j&amp;#39;, $date);$logSec = strtotime($logDay);if ($logSec &amp;gt; 1476439200) echo htmlspecialchars(file_get_contents(&amp;quot;https://chickking-website.github.io/Blog-MD/&amp;quot; . &amp;#39;post-&amp;#39; . $_GET[&amp;#39;gid&amp;#39;] . &amp;#39;.md&amp;#39;)); else echo $content; ?&amp;gt;&amp;lt;/textarea&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="网站" scheme="/tags/%E7%BD%91%E7%AB%99/"/>
    
      <category term="JavaScript" scheme="/tags/JavaScript/"/>
    
      <category term="php" scheme="/tags/php/"/>
    
  </entry>
  
</feed>
